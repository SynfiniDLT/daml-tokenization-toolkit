module Synfini.Settlement.OneTimeOffer.Test where

import DA.Set qualified as Set

import Daml.Script

import Daml.Finance.Settlement.Factory qualified as SettlementImpl
import Daml.Finance.Settlement.RouteProvider.SingleCustodian qualified as SettlementImpl

import Daml.Finance.Interface.Types.Common.Types

import Daml.Finance.Interface.Settlement.Factory qualified as SettlementFactory
import Daml.Finance.Interface.Settlement.RouteProvider qualified as RouteProvider

import Synfini.Settlement.OneTimeOffer qualified as OneTimeOfferImpl
import qualified DA.Map as Map
import qualified Synfini.Interface.Settlement.OneTimeOffer.Factory as OneTimeOfferFactory
import Daml.Finance.Interface.Settlement.Types
import qualified Synfini.Interface.Settlement.OneTimeOffer.OneTimeOffer as OneTimeOffer
import qualified Daml.Finance.Interface.Settlement.Batch as Batch

import Synfini.Tokenization.Util (assertEqMsg)
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction

data Setup = Setup
  with
    custodian1 : Party
    depository1 : Party
    issuer1 : Party
    alice : Party
    bob : Party
    charlie : Party
    settlementFactoryCid : ContractId SettlementFactory.I
    routeProviderCid : ContractId RouteProvider.I
    oneTimeOfferFactoryCid : ContractId OneTimeOfferFactory.I

withSetup : (Setup -> Script ()) -> Script ()
withSetup test = do
  provider <- allocateParty "provider"
  custodian1 <- allocateParty "custodian1"
  depository1 <- allocateParty "depository1"
  issuer1 <- allocateParty "issuer1"
  alice <- allocateParty "alice"
  bob <- allocateParty "bob"
  charlie <- allocateParty "charlie"
  let observers = Set.fromList [custodian1, depository1, issuer1, alice, bob, charlie]
  settlementFactoryCid <- toInterfaceContractId <$> submit provider do
    createCmd SettlementImpl.Factory with
      provider
      observers
  routeProviderCid <- toInterfaceContractId <$> submit provider do
    createCmd SettlementImpl.SingleCustodian with
      provider
      custodian = custodian1
      observers
  oneTimeOfferFactoryCid <- toInterfaceContractId <$> submit provider do
    createCmd OneTimeOfferImpl.Factory with
      provider
      observers = Map.fromList [("", observers)]
  test (Setup with ..)

test_bi_lateral_workflow : Script ()
test_bi_lateral_workflow = withSetup $
  \Setup {
    alice,
    bob,
    charlie,
    custodian1,
    depository1,
    issuer1,
    settlementFactoryCid,
    routeProviderCid,
    oneTimeOfferFactoryCid } -> do
  let step = Step with
        sender = alice
        receiver = bob
        quantity = Quantity with
          amount = 100.0
          unit = InstrumentKey with
            depository = depository1
            issuer = issuer1
            id = Id "ABC"
            version = "0"
  let offerId = Id "offer"
      settlers = Set.fromList [charlie]
      settlementInstructors = Set.fromList [alice]
  oneTimeOfferCid <- submit alice do
    exerciseCmd oneTimeOfferFactoryCid OneTimeOfferFactory.Create with
      offerId
      offerDescription = "desc"
      offerers = Set.fromList [alice]
      offerees = Set.fromList [bob]
      settlementTime = None
      settlementInstructors
      settlers
      minQuantity = Some 1.0
      maxQuantity = Some 2.0
      routeProviderCid
      settlementFactoryCid
      observers = Map.fromList [("", Set.fromList [charlie])]
      steps = [step]
  let acceptDescription = "accept"
  submitMustFail charlie do
    exerciseCmd oneTimeOfferCid OneTimeOffer.Accept with
      quantity = 1.5
      description = acceptDescription
  submitMustFail bob do
    exerciseCmd oneTimeOfferCid OneTimeOffer.Accept with
      quantity = 0.99
      description = acceptDescription
  submitMustFail bob do
    exerciseCmd oneTimeOfferCid OneTimeOffer.Accept with
      quantity = 2.01
      description = acceptDescription
  (batchCid, [instructionCid]) <- submit bob do
    exerciseCmd oneTimeOfferCid OneTimeOffer.Accept with
      quantity = 2.0
      description = acceptDescription
  [(activeBatchCid, Some batch)] <- queryInterface @Batch.I alice
  assertEqMsg "Must have expected batch contract ID" activeBatchCid batchCid
  assertEqMsg "Must have expected batch ID" batch.id offerId
  assertEqMsg "Must have expected batch description" batch.description acceptDescription
  assertEqMsg "Must have expected settlers" batch.settlers settlers
  assertEqMsg "Must have expected instructors" batch.requestors settlementInstructors
  [(activeInstructionCid, Some instruction)] <- queryInterface @Instruction.I alice
  assertEqMsg "Must have expected instruction contract ID" activeInstructionCid instructionCid
  assertEqMsg "Must have expected quantity" instruction.routedStep.quantity.amount 200.0
  assertEqMsg "Must have expected instrument" instruction.routedStep.quantity.unit step.quantity.unit

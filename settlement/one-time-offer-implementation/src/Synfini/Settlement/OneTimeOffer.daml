module Synfini.Settlement.OneTimeOffer where

import Synfini.Interface.Settlement.OneTimeOffer.OneTimeOffer qualified as OneTimeOffer
import DA.Set (Set)
import Daml.Finance.Interface.Settlement.Types
import Daml.Finance.Interface.Types.Common.Types
import qualified Daml.Finance.Interface.Settlement.RouteProvider as RouteProvider
import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import qualified Daml.Finance.Interface.Util.Disclosure as Disclosure
import qualified DA.Set as Set
import qualified DA.Optional as O
import qualified Daml.Finance.Util.Disclosure as ImplUtil

template OneTimeOffer
  with
    offerId : Id
    offerers : Set Party
    offerees : Set Party
    offerDescription : Text
    settlementInstructors : Set Party
    settlers : Set Party
    steps : [Step]
    settlementTime : Optional Time
    minQuantity : Optional Decimal
    maxQuantity :  Optional Decimal
    routeProviderCid : ContractId RouteProvider.I
    settlementFactoryCid : ContractId SettlementFactory.I
    observers : PartiesMap
  where
    signatory offerers

    key (offerers, offerId) : (Set Party, Id)
    maintainer key._1

    observer offerees, Disclosure.flattenObservers observers

    ensure settlementInstructors `Set.isSubsetOf` (offerers <> offerees)

    interface instance Disclosure.I for OneTimeOffer where
      view = Disclosure.View with disclosureControllers = offerers, observers
      setObservers = ImplUtil.setObserversImpl @_ @Disclosure.I this None
      addObservers = ImplUtil.addObserversImpl @_ @Disclosure.I this None
      removeObservers = ImplUtil.removeObserversImpl @_ @Disclosure.I this None

    interface instance OneTimeOffer.I for OneTimeOffer where
      view = OneTimeOffer.View with ..
      accept OneTimeOffer.Accept { id, quantity, description } = do
        assertMsg
          "Quantity must be greater than or equal to permitted minimum"
          (O.optional True (quantity >=) minQuantity)
        assertMsg
          "Quantity must be less than or equal to permitted maximum"
          (O.optional True (quantity <=) maxQuantity)
        let scaledSteps = (\step -> step with quantity.amount = quantity * step.quantity.amount) <$> steps
        routedSteps <- exercise routeProviderCid RouteProvider.Discover with
          discoverors = settlementInstructors
          contextId = Some offerId
          steps = scaledSteps
        exercise settlementFactoryCid SettlementFactory.Instruct with
          id
          contextId = Some offerId
          instructors = settlementInstructors
          settlers
          description
          routedSteps
          settlementTime
      reject _ = pure ()
      revoke _ = pure ()

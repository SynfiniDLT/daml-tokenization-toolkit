module Synfini.Settlement.Helpers where

import DA.Action (foldlA)
import DA.Map (Map)
import DA.Set (Set)

import DA.List qualified as L
import DA.List.Total qualified as List
import DA.Map qualified as Map
import DA.Optional qualified as O
import DA.Set qualified as Set

import Daml.Finance.Interface.Settlement.Types
import Daml.Finance.Interface.Types.Common.Types

import Daml.Finance.Interface.Holding.Base qualified as Holding
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction

import Synfini.Interface.Onboarding.Issuer.MinterBurner.MinterBurner qualified as MinterBurner

type InstructionIndex = Id

data AllocationHelp =
  UnallocatedHelp |
  PledgeFromFungiblesHelp |
  PledgeFromNonFungiblesHelp |
  CreditReceiverHelp |
  IssuerCreditHelp |
  UnallocateIssuerCreditHelp |
  SettleOffledgerHelp |
  PassThroughFromHelp with accountId : Id, instructionIndex : InstructionIndex
  deriving (Show, Eq)

data ApprovalHelp =
  UnapprovedHelp |
  TakeDeliveryHelp Id |
  DebitSenderHelp |
  ApproveIssuerDebitHelp |
  UnapproveIssuerDebitHelp |
  SettleOffledgerAcknowledgeHelp |
  PassThroughToHelp with accountId : Id, instructionIndex : InstructionIndex
  deriving (Show, Eq)

data HoldingDescriptor = HoldingDescriptor
  with
    instrument : InstrumentKey
    custodian : Party
  deriving (Show, Eq, Ord)

type HoldingsMap = Map HoldingDescriptor [ContractId Holding.I] 

type InstructionsMap = Map InstructionIndex (ContractId Instruction.I)

template AllocateAndApproveHelper
  with
    actors : Set Party
    holdings : HoldingsMap
    instructions : InstructionsMap
    allocations : Map InstructionIndex AllocationHelp
    approvals : Map InstructionIndex ApprovalHelp
  where
    signatory actors

    ensure all (`Map.member` instructions) (Map.keys allocations) &&
      all (`Map.member` instructions) (Map.keys approvals)

    choice AllocateAndApprove : (InstructionsMap, HoldingsMap)
      controller actors
      do
        let mapInstr (index, instructionCid) =
              (index, instructionCid, Map.lookup index allocations, Map.lookup index approvals)
        let instructionsList = mapInstr <$> (Map.toList instructions)
        foldlA (allocateAndApproveHelper actors) (instructions, holdings) instructionsList

type InstructionState = (InstructionsMap, HoldingsMap)

allocateAndApproveHelper :
  Set Party ->
  InstructionState ->
  (InstructionIndex, ContractId Instruction.I, Optional AllocationHelp, Optional ApprovalHelp) ->
  Update InstructionState
allocateAndApproveHelper actors (instructionsMap, holdingsMap) (index, instructionCid, allocation, approval) = do
  let viewer = L.head (Set.toList actors)
  instruction <- exercise instructionCid Instruction.GetView with viewer
  let holdingDescriptor = HoldingDescriptor with
        custodian = instruction.routedStep.custodian
        instrument = instruction.routedStep.quantity.unit
  (holdingsMap, instructionCid) <- case allocation of
    None -> pure (holdingsMap, instructionCid)
    Some UnallocatedHelp -> do
      (instructionCid', _) <- exercise instructionCid Instruction.Allocate with
        allocation = Unallocated
        actors
      pure (holdingsMap, instructionCid')
    Some PledgeFromFungiblesHelp -> do
      let holdings = O.fromSomeNote "Holdings not provided" (Map.lookup holdingDescriptor holdingsMap)
      (holdingCid, remainingHoldingCid) <- mergeAndSplitHelper
        (coerceContractId <$> holdings)
        instruction.routedStep.quantity.amount
      (instructionCid', _) <- exercise instructionCid Instruction.Allocate with
        allocation = Pledge (toInterfaceContractId holdingCid)
        actors
      let remainingHoldingCids = O.optional [] (\cid -> [toInterfaceContractId cid]) remainingHoldingCid
      pure (
          Map.insert holdingDescriptor remainingHoldingCids holdingsMap,
          instructionCid'
        )
    Some PledgeFromNonFungiblesHelp -> error "Non-fungible settlement not supported"
    Some IssuerCreditHelp -> do
      (instructionCid', _) <- MinterBurner.exerciseInterfaceByKey @MinterBurner.I
        (minterBurnerKey instruction)
        viewer
        MinterBurner.AllocateIssuerCredit with instructionCid
      pure (holdingsMap, instructionCid')
    Some UnallocateIssuerCreditHelp -> do
      (instructionCid', _) <- MinterBurner.exerciseInterfaceByKey @MinterBurner.I
        (minterBurnerKey instruction)
        viewer
        MinterBurner.UnallocateIssuerCredit with instructionCid
      pure (holdingsMap, instructionCid')
    Some CreditReceiverHelp -> do
      (instructionCid', _) <- exercise instructionCid Instruction.Allocate with
        allocation = CreditReceiver
        actors
      pure (holdingsMap, instructionCid')
    Some SettleOffledgerHelp -> do
      (instructionCid', _) <- exercise instructionCid Instruction.Allocate with
        allocation = SettleOffledger
        actors
      pure (holdingsMap, instructionCid')
    Some (PassThroughFromHelp accountId passThroughIndex) -> do
      let passThroughInstructionKey = InstructionKey with
            requestors = instruction.requestors
            batchId = instruction.batchId
            id = passThroughIndex
          passThroughFromAccount = AccountKey with
            custodian = instruction.routedStep.custodian
            owner = instruction.routedStep.sender
            id = accountId
      (instructionCid', _) <- exercise instructionCid Instruction.Allocate with
        allocation = PassThroughFrom (passThroughFromAccount, passThroughInstructionKey)
        actors
      pure (holdingsMap, instructionCid')
  instructionCid <- case approval of
    None -> pure instructionCid
    Some UnapprovedHelp -> exercise instructionCid Instruction.Approve with actors, approval = Unapproved
    Some (TakeDeliveryHelp accountId) -> do
      let takeDeliveryAccount = AccountKey with
            custodian = instruction.routedStep.custodian
            owner = instruction.routedStep.receiver
            id = accountId
      exercise instructionCid Instruction.Approve with actors, approval = TakeDelivery takeDeliveryAccount
    Some DebitSenderHelp -> exercise instructionCid Instruction.Approve with actors, approval = DebitSender
    Some ApproveIssuerDebitHelp -> MinterBurner.exerciseInterfaceByKey @MinterBurner.I
      (minterBurnerKey instruction)
      viewer
      MinterBurner.ApproveIssuerDebit with instructionCid
    Some UnapproveIssuerDebitHelp -> MinterBurner.exerciseInterfaceByKey @MinterBurner.I
      (minterBurnerKey instruction)
      viewer
      MinterBurner.UnapproveIssuerDebit with instructionCid
    Some SettleOffledgerAcknowledgeHelp ->
      exercise instructionCid Instruction.Approve with actors, approval = SettleOffledgerAcknowledge
    Some (PassThroughToHelp accountId passThroughIndex) -> do
      let passThroughInstructionKey = InstructionKey with
            requestors = instruction.requestors
            batchId = instruction.batchId
            id = passThroughIndex
          passThroughToAccount = AccountKey with
            custodian = instruction.routedStep.custodian
            owner = instruction.routedStep.receiver
            id = accountId
      exercise instructionCid Instruction.Approve with
        actors
        approval = PassThroughTo (passThroughToAccount, passThroughInstructionKey)
  pure (Map.insert index instructionCid instructionsMap, holdingsMap)

minterBurnerKey : Instruction.V -> MinterBurner.V
minterBurnerKey instruction = MinterBurner.View with
  custodian = instruction.routedStep.custodian
  depository = instruction.routedStep.quantity.unit.depository
  issuer = instruction.routedStep.quantity.unit.issuer

mergeAndSplitHelper : [ContractId Fungible.I] ->
                      Decimal ->
                      Update (ContractId Fungible.I, Optional (ContractId Fungible.I))
mergeAndSplitHelper holdingCids amount = do
  mergedHoldingCid <- case holdingCids of
    [] -> error "Cannot merge/split empty holdings" 
    [firstHoldingCid] -> pure firstHoldingCid
    firstHoldingCid :: others -> exercise firstHoldingCid Fungible.Merge with fungibleCids = others
  splitResult <- exercise mergedHoldingCid Fungible.Split with amounts = [amount]
  pure (
      O.fromSomeNote "Internal error: unexpected empty split result" (List.head splitResult.splitCids),
      splitResult.rest
    )

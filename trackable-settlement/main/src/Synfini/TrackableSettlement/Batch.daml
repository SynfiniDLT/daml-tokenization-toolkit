module Synfini.TrackableSettlement.Batch where

import Daml.Finance.Interface.Types.Common.Types
import Daml.Finance.Interface.Settlement.Types
import qualified Daml.Finance.Interface.Settlement.Batch as Batch
import qualified Daml.Finance.Settlement.Batch as Default
import Daml.Finance.Settlement.Instruction (Instruction)
import qualified DA.Set as Set
import DA.Foldable (forA_)

-- | Allows you to atomically settle a set of settlement `Step`.
template Batch
  with
    defaultBatch : Default.Batch
    trackers : Parties
  where
    signatory (signatory defaultBatch)
    observer (observer defaultBatch), trackers

    interface instance Batch.I for Batch where
      view = view @Batch.I (toInterface defaultBatch)
      settle args = do
        checkVisiblityOfInstructions this
        Batch.settle (toInterface defaultBatch) args

      cancel args = do
        checkVisiblityOfInstructions this
        Batch.cancel (toInterface defaultBatch) args

checkVisiblityOfInstructions : Batch -> Update ()
checkVisiblityOfInstructions Batch { defaultBatch, trackers } = do
  let Default.Batch { requestors, id, routedStepsWithInstructionId } = defaultBatch
  forA_ routedStepsWithInstructionId $ \(_, instructionId) -> do
    (_, instruction) <- fetchByKey @Instruction InstructionKey with requestors, batchId = id, id = instructionId
    let stakeholders = Set.fromList (stakeholder instruction)
    assertMsg
      "Instruction must be visible to trackers in order to settle or cancel"
      (trackers `Set.isSubsetOf` stakeholders)

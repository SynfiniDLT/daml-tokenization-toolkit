module Synfini.TrackableHolding.Fungible where

import qualified Daml.Finance.Holding.Fungible as Default
import qualified Daml.Finance.Holding.Util as ImplUtil
import qualified Daml.Finance.Util.Disclosure as ImplUtil
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import qualified Daml.Finance.Interface.Holding.Transferable as Transferable
import qualified Daml.Finance.Interface.Holding.Factory as Base
import qualified Daml.Finance.Interface.Util.Disclosure as Disclosure
import Daml.Finance.Interface.Types.Common.Types
import qualified Daml.Finance.Interface.Holding.Base as Base

-- HasField observers instance needed to make the implementation of Disclosure.I compile
instance HasField "observers" Fungible PartiesMap where
  getField f = f.defaultFungible.observers
  setField obs f = f with defaultFungible.observers = obs

template Fungible
  with
    defaultFungible : Default.Fungible
    trackers : Parties -- ^ Additional observers which cannot be removed from the contract.
  where
    signatory (signatory defaultFungible)
    observer (observer defaultFungible), trackers

    ensure (ensure defaultFungible)

    interface instance Disclosure.I for Fungible where
      view = view @Disclosure.I (toInterface defaultFungible)
      setObservers = ImplUtil.setObserversImpl @_ @Disclosure.I this None
      addObservers = ImplUtil.addObserversImpl @_ @Disclosure.I this None
      removeObservers = ImplUtil.removeObserversImpl @_ @Disclosure.I this None

    interface instance Base.I for Fungible where
      view = view @Base.I (toInterface defaultFungible)
      acquire = ImplUtil.acquireImpl this.defaultFungible.lock (\lock -> this with defaultFungible.lock = lock)
      release = ImplUtil.releaseImpl this.defaultFungible.lock (\lock -> this with defaultFungible.lock = lock)

    interface instance Transferable.I for Fungible where
      view = view @Transferable.I (toInterface defaultFungible)
      transfer = ImplUtil.transferImpl $ toInterface this

    interface instance Fungible.I for Fungible where
      view = view @Fungible.I (toInterface defaultFungible)
      split = ImplUtil.splitImpl (defaultFungible.amount) (\amount -> this with defaultFungible.amount = amount)
      merge arg@(Fungible.Merge{fungibleCids}) = do
        fungibles : [Fungible] <- mapA (fetch . coerceContractId) fungibleCids
        assertMsg
          "Can only merge with holdings that use the same trackers"
          (all (\fungible -> fungible.trackers == trackers) fungibles)
        ImplUtil.mergeImpl
          (defaultFungible.amount)
          (.defaultFungible.amount)
          (\amount -> this with defaultFungible.amount = amount)
          arg

-- HasField observers instance needed to make the implementation of Disclosure.I compile
instance HasField "observers" Factory PartiesMap where
  getField f = f.defaultFactory.observers
  setField obs f = f with defaultFactory.observers = obs

template Factory
  with
    defaultFactory : Default.Factory
    holdingTrackers : Parties
      -- ^ Parties which are always added as observers onto any Holdings created with this factory.
  where
    signatory (signatory defaultFactory)
    observer (observer defaultFactory)

    interface instance Base.F for Factory
      where
        view = view @Base.F (toInterface defaultFactory)
        create' args = do
          defaultFungibleCid <- Base.create' (toInterface defaultFactory) args
          defaultFungible <- fetch (coerceContractId defaultFungibleCid)
          archive defaultFungibleCid
          toInterfaceContractId <$>
            create Fungible with defaultFungible, trackers = holdingTrackers

    interface instance Disclosure.I for Factory where
      view = view @Disclosure.I (toInterface defaultFactory)
      setObservers = ImplUtil.setObserversImpl @Factory @Disclosure.I this None
      addObservers = ImplUtil.addObserversImpl @Factory @Disclosure.I this None
      removeObservers = ImplUtil.removeObserversImpl @Factory @Disclosure.I this None

module Synfini.Onboarding.Account.OpenOffer where

import qualified Daml.Finance.Interface.Account.Account as Account
import qualified Daml.Finance.Interface.Account.Factory as Account
import qualified Daml.Finance.Interface.Holding.Factory as Holding
import Daml.Finance.Interface.Types.Common.Types
import qualified DA.Optional as O
import qualified DA.Set as Set
import DA.Set (Set)
import Synfini.Onboarding.Types
import Synfini.Onboarding.Factory.Account
import Synfini.Onboarding.Factory.Holding
import Daml.Script
import DA.Foldable (forA_)
import qualified DA.Map as Map

template OpenAccountOffer
  with
    custodian : Party
    operators : Account.Controllers
    ownerIncomingControlled : Bool
    ownerOutgoingControlled : Bool
    accountFactoryCid : ContractId Account.F
    holdingFactoryCid : ContractId Holding.F
    observers : Set Party
  where
    signatory custodian

    observer observers

    nonconsuming choice OpenAccount : ContractId Account.I
      with
        owner : Party
        id : Id
        description : Text
        accountObservers : PartiesMap
      controller owner
      do
        let account = AccountKey with custodian, owner, id
        existingAccount <- lookupByKey @Account.R account
        assertMsg "Cannot already have an account with same key" (O.isNone existingAccount)
        let incomingControllers =
              (if ownerIncomingControlled then Set.fromList [owner] else Set.empty) <> operators.incoming
            outgoingControllers =
              (if ownerOutgoingControlled then Set.fromList [owner] else Set.empty) <> operators.outgoing
        exercise accountFactoryCid Account.Create with
          account
          holdingFactoryCid
          controllers = Account.Controllers with incoming = incomingControllers, outgoing = outgoingControllers
          description
          observers = accountObservers

data CreateOpenAccountOfferSettings = CreateOpenAccountOfferSettings
  with
    label : Text
    custodian : Text
    incomingOperators : [Text]
    outgoingOperators : [Text]
    ownerIncomingControlled : Bool
    ownerOutgoingControlled : Bool
    accountFactory : Text
    holdingFactory : Text
    observers : [Text]

data CreateOpenAccountOfferInput = CreateOpenAccountOfferInput
  with
    parties : [PartyInfo]
    accountFactories : [AccountFactory]
    holdingFactories : [HoldingFactory]
    offerSettings : [CreateOpenAccountOfferSettings]

data LabelledOpenAccountOffer = LabelledOpenAccountOffer
  with
    label : Text
    cid : ContractId OpenAccountOffer

data CreateOpenAccountOfferOutput = CreateOpenAccountOfferOutput
  with
    accountOpenOffers : [LabelledOpenAccountOffer]

createOpenAccountOffer : CreateOpenAccountOfferInput -> Script CreateOpenAccountOfferOutput
createOpenAccountOffer input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  accountOpenOffers <- forA input.offerSettings $ \offerSetting -> do
    let custodian = p offerSetting.custodian
        operators = Account.Controllers with
          incoming = Set.fromList (p <$> offerSetting.incomingOperators)
          outgoing = Set.fromList (p <$> offerSetting.outgoingOperators)
        accountFactoryCid = findFactoryContractId offerSetting.accountFactory input.accountFactories
        holdingFactoryCid = findFactoryContractId offerSetting.holdingFactory input.holdingFactories
    let openAccountOffer = OpenAccountOffer with
          custodian
          operators
          ownerIncomingControlled = offerSetting.ownerIncomingControlled
          ownerOutgoingControlled = offerSetting.ownerOutgoingControlled
          accountFactoryCid
          holdingFactoryCid
          observers = Set.fromList (p <$> offerSetting.observers)
    cid <- submit custodian do createCmd openAccountOffer
    pure LabelledOpenAccountOffer with label = offerSetting.label, cid
  pure CreateOpenAccountOfferOutput with accountOpenOffers

data AccountSettings = AccountSettings
  with
    offer : Text
    owner : Text
    id : Text
    description : Text
    observers : [Observer]

data OpenAccountsInput = OpenAccountsInput
  with
    parties : [PartyInfo]
    accountOpenOffers : [LabelledOpenAccountOffer]
    readAs : [Text]
    accountSettings : [AccountSettings]

openAccounts : OpenAccountsInput -> Script ()
openAccounts input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  let readAs = p <$> input.readAs
  let offersMap = Map.fromList $ (\o -> (o.label, o.cid)) <$> input.accountOpenOffers
  forA_ input.accountSettings \settings -> do
    let owner = p settings.owner
        openAccountOfferCid = O.fromSomeNote
          ("Offer not found: " <> settings.offer)
          (Map.lookup settings.offer offersMap)
    submitMulti [owner] readAs do
      exerciseCmd openAccountOfferCid OpenAccount with
        owner
        id = Id settings.id
        description = settings.description
        accountObservers = asPartiesMap p settings.observers

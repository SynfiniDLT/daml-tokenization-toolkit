{-# LANGUAGE ApplicativeDo #-}

module Synfini.Onboarding.Mint.Instruct where

import qualified Daml.Finance.Interface.Holding.Util as Holding
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import Daml.Finance.Interface.Types.Common.Types
import Daml.Script
import qualified DA.Set as Set
import Synfini.Mint
import Synfini.Onboarding.Types
import Synfini.Mint.Delegation
import qualified Daml.Finance.Interface.Account.Util as Account
import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified DA.Optional as O

data InstructMintSettings = InstructMintSettings
  with
    instrumentDepository : Text
    instrumentIssuer : Text
    instrumentId : Text
    instrumentVersion: Text
    instructor : Text
    custodian : Text
    operators : [Text]
    receiver : Text
    receiverAccountId : Text
    referenceId : Text
    amount : Decimal

data InstructMintInput = InstructMintInput
  with
    readAs : [Text]
    parties : [PartyInfo]
    instructMintSettings : InstructMintSettings

data ExecuteMintSettings = ExecuteMintSettings
  with
    issuer : Party
    minterBurner : Party
    referenceId : Id

data InstructMintOutput = InstructMintOutput
  with
    executeMintSettings : ExecuteMintSettings

instructMint : InstructMintInput -> Script InstructMintOutput
instructMint input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  let issuer = p input.instructMintSettings.instrumentIssuer
      depository = p input.instructMintSettings.instrumentDepository
      instructor = p input.instructMintSettings.instructor
      receiver = p input.instructMintSettings.receiver
      receiverAccountId = Id input.instructMintSettings.receiverAccountId
      custodian = p input.instructMintSettings.custodian
      operators = Set.fromList (p <$> input.instructMintSettings.operators)
      readAs = p <$> input.readAs
      id = Id input.instructMintSettings.referenceId
      amount = input.instructMintSettings.amount
      description = "Delivery of " <> show input.instructMintSettings.instrumentId  <> " requested by " <> show instructor
  let instrument = InstrumentKey with
        issuer
        depository
        version = input.instructMintSettings.instrumentVersion
        id = Id input.instructMintSettings.instrumentId
      receiverAccount = AccountKey with
        owner = receiver
        custodian
        id = receiverAccountId

  instructionCid <-
    if instructor /= receiver then do
      let minterKey = MinterKey with operators, minter = instructor, instrument
      submitMulti [instructor] readAs do
        exerciseByKeyCmd @Minter minterKey MinterInstructMint with
          receiver
          receiverAccountId
          id
          amount
          description
    else do
      let receiverKey = MintReceiverKey with operators, instrument, receiverAccount
      submitMulti [instructor] readAs do
        exerciseByKeyCmd @MintReceiver receiverKey ReceiverInstructMint with
          amount
          description
          id

  Some instruction <- queryContractId instructor instructionCid
  pure InstructMintOutput with
    executeMintSettings = ExecuteMintSettings with
      issuer
      minterBurner = instruction.minterBurner
      referenceId = instruction.id

data ExecuteMintInput = ExecuteMintInput
  with
    parties : [PartyInfo]
    readAs : [Text]
    executeMintSettings : ExecuteMintSettings

executeMint : ExecuteMintInput -> Script ()
executeMint input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  let readAs = p <$> input.readAs
  submitMulti [input.executeMintSettings.minterBurner] readAs do
    exerciseByKeyCmd
      @MintInstruction
      (
        input.executeMintSettings.issuer,
        input.executeMintSettings.referenceId
      )
      ExecuteMint
  pure ()

data InstructBurnSettings = InstructBurnSettings
  with
    instrumentDepository : Text
    instrumentIssuer : Text
    instrumentId : Text
    instrumentVersion: Text
    sender : Text
    operators : [Text]
    custodian : Text
    senderAccountId : Text
    referenceId : Text
    amount : Decimal

data InstructBurnInput = InstructBurnInput
  with
    readAs : [Text]
    parties : [PartyInfo]
    instructBurnSettings : InstructBurnSettings

instructBurn : InstructBurnInput -> Script ()
instructBurn input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  let issuer = p input.instructBurnSettings.instrumentIssuer
      depository = p input.instructBurnSettings.instrumentDepository
      sender = p input.instructBurnSettings.sender
      custodian = p input.instructBurnSettings.custodian
      operators = Set.fromList (p <$> input.instructBurnSettings.operators)
      readAs = p <$> input.readAs
  let instrument = InstrumentKey with
        issuer, depository, id = Id input.instructBurnSettings.instrumentId, version = input.instructBurnSettings.instrumentVersion
      senderAccount = AccountKey with custodian, owner = sender, id = Id input.instructBurnSettings.senderAccountId
  holdings <- queryInterface @Holding.I sender
  let relevantHoldings = filter
        (\(_, Some v) -> v.account == senderAccount && v.instrument == instrument && O.isNone v.lock)
        holdings
  let receiverKey = MintReceiverKey with receiverAccount = senderAccount, operators, instrument
  submitMulti [sender] readAs do
    exerciseByKeyCmd @MintReceiver receiverKey ReceiverInstructBurn with
      holdingCids = coerceInterfaceContractId . fst <$> relevantHoldings
      id = Id input.instructBurnSettings.referenceId
      amount = input.instructBurnSettings.amount
      description = "Redemption of " <> show instrument.id <> " requested by " <> show sender
  pure ()

data ExecuteBurnSettings = ExecuteBurnSettings
  with
    issuer : Text
    minterBurner : Text
    referenceId : Text

data ExecuteBurnInput = ExecuteBurnInput
  with
    parties : [PartyInfo]
    readAs : [Text]
    executeBurnSettings : ExecuteBurnSettings

executeBurn : ExecuteBurnInput -> Script ()
executeBurn input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  let issuer = p input.executeBurnSettings.issuer
      minterBurner = p input.executeBurnSettings.minterBurner
      readAs = p <$> input.readAs
      referenceId = Id input.executeBurnSettings.referenceId
  let burnInstructionKey = (issuer, referenceId)
  Some (burnInstructionCid, instruction) <- queryContractKey @BurnInstruction minterBurner burnInstructionKey
  let instrument = instruction.quantity.unit
      supplyAccount = AccountKey with
            custodian = instruction.custodian
            owner = minterBurner
            id = instruction.supplyAccountId
  holdings <- queryInterface @Holding.I minterBurner
  let relevantHoldings = filter
        (\(_, Some v) -> v.account == supplyAccount && v.instrument == instrument && O.isNone v.lock)
        holdings
  submitMulti [minterBurner] readAs do
    createAndExerciseCmd (AllocateBurnSupplyHelper minterBurner)
      (
        AllocateBurnSupplyFromFungibles with
          holdingCids = coerceInterfaceContractId . fst <$> relevantHoldings
          burnInstructionCid
      )
    exerciseByKeyCmd @BurnInstruction burnInstructionKey ExecuteBurn
    pure ()

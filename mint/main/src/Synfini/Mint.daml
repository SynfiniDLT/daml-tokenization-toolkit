module Synfini.Mint where

import Daml.Finance.Interface.Account.Util (fetchAccount)
import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Holding.Util as Holding
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import qualified Daml.Finance.Interface.Settlement.Batch as Batch
import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types
import Synfini.Tokenization.Util
import qualified DA.List.Total as List
import qualified DA.Optional as O
import DA.Set (Set)
import qualified DA.Set as Set

template Mint
  with
    custodian : Party
    receiverAuthorisers : Set Party
    minterBurner : Party
    supplyAccountId : Id
    instrument : InstrumentKey
    settlementFactoryCid : ContractId SettlementFactory.I
    observers : Set Party
  where
    signatory custodian, minterBurner, instrument.issuer, receiverAuthorisers

    observer observers

    key instrument : InstrumentKey
    maintainer key.issuer

    nonconsuming choice InstructMint : ContractId MintInstruction
      with
        instructor : Party
        receiver : Party
        receiverAccountId : Id
        amount : Decimal
        id : Id
        description : Text
      controller instructor
      do
        assertMsgPrefixed
          "Mint instructor must be owner or minter/burner"
          (instructor == receiver || instructor == minterBurner)

        let allActors = Set.fromList [custodian, instructor] <> receiverAuthorisers
            onlyCustodian = Set.fromList [custodian]
            quantity = Quantity with unit = instrument, amount
        let custodianToOwner = RoutedStep with
              custodian
              sender = custodian
              receiver
              quantity
            custodianToMb = RoutedStep with
              custodian
              sender = custodian
              receiver = minterBurner
              quantity
        existingInstructionCid <- lookupByKey @MintInstruction (allActors, id)
        assertMsg "Instructiona already exists for this ID" (O.isNone existingInstructionCid)
        (batchCid, [custodianToOwnerCid, custodianToMbCid]) <- exercise
          settlementFactoryCid
          SettlementFactory.Instruct with
            instructors = allActors
            settlers = Set.fromList [minterBurner]
            id
            description
            contextId = None
            routedSteps = [custodianToOwner, custodianToMb]
            settlementTime = None

        (allocatedCustodianToOwnerCid, _) <- exercise custodianToOwnerCid Instruction.Allocate with
          actors = onlyCustodian
          allocation = CreditReceiver
        approvedCustodianToOwnerCid <- exercise allocatedCustodianToOwnerCid Instruction.Approve with
          actors = onlyCustodian <> receiverAuthorisers
          approval = TakeDelivery (AccountKey with custodian, owner = receiver, id = receiverAccountId)

        (allocatedCustodianToMbCid, _) <- exercise custodianToMbCid Instruction.Allocate with
          actors = onlyCustodian
          allocation = CreditReceiver
        exercise allocatedCustodianToMbCid Instruction.Approve with
          actors = Set.fromList [custodian, minterBurner]
          approval = TakeDelivery (AccountKey with custodian, owner = minterBurner, id = supplyAccountId)

        create MintInstruction with
          custodian
          minterBurner
          requestors = allActors
          id
          quantity = Quantity with unit = instrument, amount
          batchCid

    nonconsuming choice InstructBurn : ContractId BurnInstruction
      with
        instructor : Party
        holdingCid : ContractId Holding.I
        id : Id
        description : Text
      controller instructor
      do
        holding <- fetch holdingCid
        let holdingView = view holding
        assertMsgPrefixed "Burn instructor must be the owner" (holdingView.account.owner == instructor)
        assertMsgPrefixed "Holding to be burned must have expected instrument" (holdingView.instrument == instrument)
        assertMsgPrefixed "Holding to be burned must have expected custodian" (holdingView.account.custodian == custodian)
        assertMsgPrefixed "Holding to be burned cannot already be locked" (O.isNone holdingView.lock)

        let allActors = Set.fromList [custodian, instructor] <> receiverAuthorisers
            onlyCustodian = Set.fromList [custodian]
            quantity = Quantity with unit = holdingView.instrument, amount = holdingView.amount
        let ownerToCustodian = RoutedStep with
              custodian
              sender = holdingView.account.owner
              receiver = custodian
              quantity
            mbToCustodian = RoutedStep with
              custodian
              sender = minterBurner
              receiver = custodian
              quantity
        (batchCid, [ownerToCustodianCid, mbToCustodianCid]) <- exercise
          settlementFactoryCid
          SettlementFactory.Instruct with
            instructors = allActors
            settlers = Set.fromList [minterBurner]
            id
            description
            contextId = None
            routedSteps = [ownerToCustodian, mbToCustodian]
            settlementTime = None

        (allocatedOwnerToCustodianCid, _) <- exercise ownerToCustodianCid Instruction.Allocate with
          actors = allActors
          allocation = Pledge holdingCid

        -- TODO is the holding lock check needed?
        Pledge ownerHoldingCid <- (.allocation) <$> exercise allocatedOwnerToCustodianCid Instruction.GetView with
          viewer = instructor
        -- lockedHolding <- exercise lockedHoldingCid Holding.GetView with viewer = instructor
        -- let lockOpt = lockedHolding.lock
        -- assertMsgPrefixed "Holding must have lock" (isSome lockOpt)
        -- let (Some lock) = lockOpt
        -- assertMsgPrefixed "Holding must be locked by custodian" (Set.member custodian lock.lockers)

        approvedOwnerToCustodianCid <- exercise allocatedOwnerToCustodianCid Instruction.Approve with
          actors = onlyCustodian
          approval = DebitSender

        approvedMbToCustodianCid <- exercise mbToCustodianCid Instruction.Approve with
          actors = onlyCustodian
          approval = DebitSender

        create BurnInstruction with
          custodian
          minterBurner
          supplyAccountId
          quantity = Quantity with unit = instrument, amount = holdingView.amount
          requestors = allActors
          batchCid
          ownerHoldingCid
          supplyInstructionCid = approvedMbToCustodianCid
          isAllocated = False

data ExecuteMintResult = ExecuteMintResult
  with
    receiverHoldingCid : ContractId Holding.I
    supplyHoldingCid : ContractId Holding.I
  deriving (Show, Eq)

template MintInstruction
  with
    custodian : Party
    minterBurner : Party
    requestors : Set Party
    id : Id
    quantity : Quantity InstrumentKey Decimal
    batchCid : ContractId Batch.I
  where
    signatory custodian, minterBurner, requestors

    key (requestors, id) : (Set Party, Id)
    maintainer key._1

    choice ExecuteMint : ExecuteMintResult
      controller minterBurner
      do
        [receiverHoldingCid, supplyHoldingCid] <- exercise batchCid Batch.Settle with
          actors = Set.fromList [minterBurner]
        pure ExecuteMintResult with receiverHoldingCid, supplyHoldingCid

    choice RejectMint : ()
      controller minterBurner
      do
        exercise batchCid Batch.Cancel with actors = Set.insert minterBurner requestors
        pure ()

data InstructBurnFromFungiblesResult = InstructBurnFromFungiblesResult
  with
    burnInstructionCid : ContractId BurnInstruction
    remainingHoldingCid : Optional (ContractId Fungible.I)
  deriving (Show, Eq)

template InstructBurnHelper
  with
    instructor : Party
  where
    signatory instructor

    choice InstructBurnFromFungibles : InstructBurnFromFungiblesResult
      with
        amount : Decimal
        holdingCids : [ContractId Fungible.I]
        id : Id
        description : Text
      controller instructor
      do
        (holdingCidToBurn, remainingHoldingCid) <- mergeAndSplitHelper1 holdingCids amount
        holdingToBurn <- fetch holdingCidToBurn
        burnInstructionCid <- exerciseByKey @Mint (Holding.getInstrument holdingToBurn) InstructBurn with
          instructor
          holdingCid = toInterfaceContractId holdingCidToBurn
          id
          description
        pure InstructBurnFromFungiblesResult with burnInstructionCid, remainingHoldingCid

data RejectBurnResult = RejectBurnResult
  with
    releasedOwnerHoldingCid : ContractId Holding.I
    releasedSupplyHoldingCid : Optional (ContractId Holding.I)
  deriving (Show, Eq)

template BurnInstruction
  with
    custodian : Party
    minterBurner : Party
    requestors : Set Party
    supplyAccountId : Id
    quantity : Quantity InstrumentKey Decimal
    ownerHoldingCid : ContractId Holding.I
    batchCid : ContractId Batch.I
    supplyInstructionCid : ContractId Instruction.I
    isAllocated : Bool
  where
    signatory custodian, minterBurner, requestors

    choice ExecuteBurn : ()
      controller minterBurner
      do
        exercise batchCid Batch.Settle with actors = Set.fromList [minterBurner]
        pure ()

    choice AllocateBurnSupply : ContractId BurnInstruction
      with
        holdingCid : ContractId Holding.I
      controller minterBurner
      do
        ownerHolding <- fetch ownerHoldingCid
        holding <- fetch holdingCid
        assertMsgPrefixed
          "Allocations must have same template type rep"
          (interfaceTypeRep ownerHolding == interfaceTypeRep holding)
        let holdingView = view holding
        assertMsgPrefixed "Burn supply must be from expected account" (holdingView.account.id == supplyAccountId)
        assertMsgPrefixed "Burn supply cannot already be locked" (O.isNone holdingView.lock)

        (newSupplyInstructionCid, _) <- exercise supplyInstructionCid Instruction.Allocate with
          actors = Set.fromList [custodian, minterBurner]
          allocation = Pledge holdingCid
        create this with supplyInstructionCid = newSupplyInstructionCid, isAllocated = True

    choice RejectBurn : RejectBurnResult
      controller minterBurner
      do
        releasedHoldingCids <- exercise batchCid Batch.Cancel with actors = Set.insert minterBurner requestors
        let (releasedOwnerHoldingCid, releasedSupplyHoldingCid) = case releasedHoldingCids of
              [h1, h2] -> (h1, Some h2)
              [h1] -> (h1, None)
              _ -> errorPrefixed "Internal error: expected one or two released holdings"
        pure RejectBurnResult with releasedOwnerHoldingCid, releasedSupplyHoldingCid

data AllocateBurnSupplyFromFungiblesResult = AllocateBurnSupplyFromFungiblesResult
  with
    burnInstructionCid : ContractId BurnInstruction
    remainingHoldingCid : Optional (ContractId Fungible.I)
  deriving (Show, Eq)

template AllocateBurnSupplyHelper
  with
    minterBurner : Party
  where
    signatory minterBurner

    choice AllocateBurnSupplyFromFungibles : AllocateBurnSupplyFromFungiblesResult
      with
        burnInstructionCid : ContractId BurnInstruction
        holdingCids : [ContractId Fungible.I]
      controller minterBurner
      do
        burnInstruction <- fetch burnInstructionCid
        (holdingCidToAllocate, remainingHoldingCid) <- mergeAndSplitHelper1 holdingCids burnInstruction.quantity.amount
        burnInstructionCid' <- exercise burnInstructionCid AllocateBurnSupply with
          holdingCid = toInterfaceContractId holdingCidToAllocate
        pure AllocateBurnSupplyFromFungiblesResult with
          burnInstructionCid = burnInstructionCid'
          remainingHoldingCid

msgPrefix : Text
msgPrefix = "Mint: "

assertMsgPrefixed : CanAssert m => Text -> Bool -> m ()
assertMsgPrefixed msg = assertMsg (msgPrefix <> " " <> msg)

errorPrefixed : Text -> a
errorPrefixed msg = error (msgPrefix <> " " <> msg)

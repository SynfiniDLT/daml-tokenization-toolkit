module Synfini.Mint.Test where

import qualified Daml.Finance.Interface.Account.Account as Account
import qualified Daml.Finance.Interface.Account.Factory as Account
import Daml.Finance.Interface.Types.Common.Types
import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Holding.Factory as Holding
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import qualified Daml.Finance.Interface.Settlement.Factory as Settlement

import qualified Daml.Finance.Account.Account as AccountImpl
import qualified Daml.Finance.Holding.Fungible as FungibleImpl
import qualified Daml.Finance.Holding.NonFungible as NonFungibleImpl
import qualified Daml.Finance.Settlement.Factory as SettlementImpl

import Daml.Script
import qualified DA.Map as Map
import qualified DA.Set as Set
import Synfini.Mint
import qualified Daml.Finance.Interface.Settlement.Types as Instruction
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible

_supplyAccountId : Id
_supplyAccountId = Id "supply"

aliceAccountId : Id
aliceAccountId = Id "0"

aliceAccount : Setup -> AccountKey
aliceAccount s = AccountKey with custodian = s.custodian, owner = s.alice, id = aliceAccountId

mintInstrumentId = Id "MyCoin"
mintInstrumentVersion = "0"

mintInstrument : Setup -> InstrumentKey
mintInstrument s = InstrumentKey with
  issuer = s.issuer
  depository = s.depository
  id = mintInstrumentId
  version = mintInstrumentVersion

data Setup = Setup
  with
    public : Party
    custodian : Party
    issuer : Party
    depository : Party
    minterBurner : Party
    serviceProvider : Party
    alice : Party
    mintCid : ContractId Mint
  deriving (Show, Eq)

doSetup : Script Setup
doSetup = do
  public <- allocateParty "public"
  custodian <- allocateParty "custodian"
  issuer <- allocateParty "issuer"
  depository <- allocateParty "depository"
  minterBurner <- allocateParty "minterBurner"
  serviceProvider <- allocateParty "serviceProvider"
  alice <- allocateParty "alice"

  holdingFactoryCid : ContractId Holding.Factory <- fmap toInterfaceContractId . submit custodian $
    createCmd FungibleImpl.Factory with
      provider = custodian
      observers = Map.fromList [("public", Set.fromList [public])]
  accountFactoryCid : ContractId Account.Factory <- fmap toInterfaceContractId . submit custodian $
    createCmd AccountImpl.Factory with
      provider = custodian
      observers = Map.fromList [("public", Set.fromList [public])]
  settlementFactoryCid : ContractId Settlement.Factory <- fmap toInterfaceContractId . submit custodian $
    createCmd SettlementImpl.Factory with
      provider = custodian
      observers = Set.fromList [public]

  let supplyAccount = AccountKey with
        custodian
        owner = minterBurner
        id = _supplyAccountId
  submitMulti [custodian, minterBurner] [] $ exerciseCmd accountFactoryCid Account.Create with
    account = supplyAccount
    controllers = Account.Controllers with
      incoming = Set.fromList [custodian, minterBurner]
      outgoing = Set.fromList [custodian, minterBurner]
    holdingFactoryCid
    description = "Supply account"
    observers = Map.fromList [("public", Set.fromList [public])]

  let aliceAccount = AccountKey with
        custodian
        owner = alice
        id = aliceAccountId
  submitMulti [custodian, alice] [] $ exerciseCmd accountFactoryCid Account.Create with
    account = aliceAccount
    controllers = Account.Controllers with
      incoming = Set.fromList [serviceProvider]
      outgoing = Set.fromList [serviceProvider, alice]
    holdingFactoryCid
    description = "Alice's account"
    observers = Map.fromList [("Issuer", Set.fromList [minterBurner])]

  mintCid <- submitMulti [custodian, issuer, depository, minterBurner, serviceProvider] [] $ createCmd Mint with
    custodian
    minterBurner = minterBurner
    receiverAuthorisers = Set.fromList [serviceProvider]
    supplyAccountId = supplyAccount.id
    instrument = InstrumentKey with issuer, depository, id = mintInstrumentId, version = mintInstrumentVersion
    settlementFactoryCid
    observers = Set.fromList [public]

  pure Setup with ..

withSetup : (Setup -> Script a) -> Script ()
withSetup test = do
  s <- doSetup
  test s
  pure ()

instructMint : IsParties p => Setup -> p -> Party -> Id -> Decimal -> Id -> Script (ContractId MintInstruction)
instructMint setup instructors receiver receiverAccountId amount id = do
  let instructorsList = toParties instructors
  submitMulti instructorsList [setup.public] $ exerciseCmd setup.mintCid InstructMint with
    instructors = Set.fromList instructorsList
    receiver
    receiverAccountId
    amount
    id
    description = "description"

test_instructMint : Script ()
test_instructMint = pure () -- TODO

test_rejectMint : Script ()
test_rejectMint = withSetup $ \setup -> do
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId 99.9 (Id "ref1")
  submitMultiMustFail [setup.custodian] [setup.public] $ exerciseCmd mintInstructionCid RejectMint
  submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid RejectMint
  activeInstructions <- query @MintInstruction setup.alice
  assertMsg "Instructions must be empty" (null activeInstructions)

test_acceptMint : Script ()
test_acceptMint = withSetup $ \setup -> do
  let amount = 99.9
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId amount (Id "ref1")
  submitMultiMustFail [setup.custodian] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint
  mintResult <- submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint
  [(aliceHoldingCid, Some aliceHolding)] <- queryInterface @Holding.I setup.alice
  assertMsg "Reciever must have correct contract ID" (aliceHoldingCid == mintResult.receiverHoldingCid)
  assertMsg "Receiver must have correct amount" (aliceHolding.amount == amount)
  [(minterBurnerHoldingCid, Some minterBurnerHolding)] <- queryInterface @Holding.I setup.minterBurner
  assertMsg "Minter/burner must have correct contract ID" (minterBurnerHoldingCid == mintResult.supplyHoldingCid)
  assertMsg "Minter/burner must have correct amount" (minterBurnerHolding.amount == amount)

test_instructBurn : Script ()
test_instructBurn = pure () -- TODO

test_rejectBurn : Script ()
test_rejectBurn = withSetup $ \setup -> do
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId 99.9 (Id "ref1")
  mintResult <- submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint
  burnInstructionCid <- submitMulti [setup.alice] [setup.public] $ exerciseCmd setup.mintCid InstructBurn with
    instructors = Set.fromList [setup.alice]
    holdingCid = mintResult.receiverHoldingCid
    id = Id "ref2"
    description = "Burn"
  submitMultiMustFail [setup.custodian] [setup.public] $ exerciseCmd burnInstructionCid RejectBurn
  submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd burnInstructionCid RejectBurn
  activeInstructions <- query @BurnInstruction setup.alice
  assertMsg "Instructions must be empty" (null activeInstructions)

test_attemptBurnWithBadHoldingTemplate : Script ()
test_attemptBurnWithBadHoldingTemplate = withSetup $ \setup -> do
  let mintAmount = 99.9
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId mintAmount (Id "ref1")
  mintResult <- submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint

  nonFungibleCid <- submitMulti [setup.custodian, setup.alice] [] $ createCmd
    NonFungibleImpl.NonFungible with
      instrument = mintInstrument setup
      account = aliceAccount setup
      amount = mintAmount
      lock = None
      observers = Map.fromList [("obs", Set.fromList [setup.minterBurner])]

  burnInstructionCid <- submitMulti [setup.alice] [setup.public] $ exerciseCmd setup.mintCid InstructBurn with
    instructors = Set.fromList [setup.alice]
    holdingCid = toInterfaceContractId nonFungibleCid
    id = Id "ref2"
    description = "Burn"
  submitMultiMustFail [setup.minterBurner] [setup.public] $ exerciseCmd burnInstructionCid AllocateBurnSupply with
    holdingCid = mintResult.supplyHoldingCid

test_attemptBurnAndChangeAllocation : Script ()
test_attemptBurnAndChangeAllocation = withSetup $ \setup -> do
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId 100.0 (Id "ref1")
  mintResult <- submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint
  let mintAmount = 50.0
  let aliceFungibleCid : ContractId Fungible.I = coerceInterfaceContractId mintResult.receiverHoldingCid
  [holdingCid, otherHoldingCid] <- (.splitCids) <$>
    submit setup.alice (exerciseCmd aliceFungibleCid Fungible.Split with amounts = [mintAmount, mintAmount])

  burnInstructionCid <- submitMulti [setup.alice] [setup.public] $ exerciseCmd setup.mintCid InstructBurn with
    instructors = Set.fromList [setup.alice]
    holdingCid = toInterfaceContractId holdingCid
    id = Id "ref2"
    description = "Burn"

  instructions <- queryInterface @Instruction.I setup.alice
  let [(instructionFromAliceCid, Some _)] = filter (\(_, Some v) -> v.routedStep.sender == setup.alice) instructions
  -- Cannot change allocation without permission of custodian
  -- This stops the sender from re-allocating using an invalid holding
  submitMultiMustFail [setup.alice, setup.serviceProvider] [setup.public] $
    exerciseCmd instructionFromAliceCid Instruction.Allocate with
      actors = Set.fromList [setup.alice, setup.serviceProvider]
      allocation = Instruction.Pledge (toInterfaceContractId otherHoldingCid)

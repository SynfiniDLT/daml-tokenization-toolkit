module Synfini.Fund.Offer.Delegation where

import Synfini.Fund.Offer
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import Daml.Finance.Interface.Types.Common.Types
import DA.Set (Set)
import qualified DA.Set as Set
import Synfini.Tokenization.Util (mergeAndSplitHelper2)

data FundInvestorKey = FundInvestorKey
  with
    investorAccount : AccountKey
    unitsInstrument : InstrumentKey
    operators : Set Party
  deriving (Show, Eq, Ord)

template FundInvestor
  with
    investorAccount : AccountKey
    unitsInstrument : InstrumentKey
    operators : Set Party
  where
    signatory operators

    observer investor

    key FundInvestorKey with investorAccount, unitsInstrument, operators : FundInvestorKey
    maintainer key.operators

    let investor = investorAccount.owner

    nonconsuming choice RequestInvestment : ContractId FundPurchaseInstruction
      with
        numUnits : Int
        paymentCids : [ContractId Fungible.I]
        offerCid : ContractId FundOffer
        investmentId : Id
      controller investor
      do
        offer <- exercise offerCid GetFundOfferPayload with viewer = investor
        assertMsg "Offer must be for the allowed instrument" (offer.unitsInstrument == unitsInstrument)

        let numUnitsDecimal = intToDecimal numUnits
        (investorToFundPaymentCid, investorToFundManagerPaymentCid, _) <- mergeAndSplitHelper2
          paymentCids
          (numUnitsDecimal * offer.costPerUnit)
          (numUnitsDecimal * offer.commission * offer.costPerUnit)

        exercise offerCid InstructPurchase with
          numUnits
          investorToFundPaymentCid = toInterfaceContractId investorToFundPaymentCid
          investorToFundManagerPaymentCid = toInterfaceContractId investorToFundManagerPaymentCid
          actors = Set.insert investor operators
          investmentId
          investorAccountId = investorAccount.id

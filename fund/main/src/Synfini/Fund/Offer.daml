module Synfini.Fund.Offer where

import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import Daml.Finance.Interface.Settlement.Types
import Daml.Finance.Interface.Types.Common.Types
import DA.Set (Set)
import qualified DA.Set as Set
import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import qualified Daml.Finance.Interface.Settlement.Batch as Batch

data InstructPurchaseResult = InstructPurchaseResult
  with
    batchCid : ContractId Batch.I
    investorToFundInstructionCid : ContractId Instruction.I
    investorToFundManagerInstructionCid : ContractId Instruction.I
    fundToInvestorInstructionCid : ContractId Instruction.I
  deriving (Show, Eq)

template FundOffer
  with
    fund : Party
    fundManager : Party
    fundCustodian : Party -- Custodian at which fund units are held (can also be the fund)
    unitsInstrument : InstrumentKey
    paymentInstrument : InstrumentKey
    costPerUnit : Decimal
    commission : Decimal
    minInvesment : Decimal -- Minimum investment amount (measured in units of the payment instrument, not including
    -- commission fees)
    fundPaymentAccountId : Id -- Account where fund receives payments
    fundManagerPaymentAccountId : Id -- Account where fund manager receives commissions
    paymentCustodian : Party -- Custodian at which all payment assets must be held
    settlementFactoryCid : ContractId SettlementFactory.I
    observers : Set Party
  where
    signatory fund, fundCustodian, fundManager -- In practice these parties may be the same

    observer observers

    ensure commission > 0.0 && costPerUnit > 0.0 && minInvesment > 0.0

    nonconsuming choice InstructPurchase : InstructPurchaseResult
      with
        numUnits : Int
        investorToFundPaymentCid : ContractId Holding.I
        investorToFundManagerPaymentCid : ContractId Holding.I
        actors : Set Party
        investorAccountId: Id
        investmentId : Id
      controller actors
      do
        let numUnitsDecimal = intToDecimal numUnits
        let cost = numUnitsDecimal * costPerUnit
        let commissionCost = cost * commission

        assertMsg "Must invest minimum amount" (cost >= minInvesment)

        investorToFundPayment <- view <$> (fetch investorToFundPaymentCid)
        investorToFundManagerPayment <- view <$> (fetch investorToFundManagerPaymentCid)

        let investor = investorToFundPayment.account.owner
        assertMsg
          "Both payments must come from the same investor"
          (investor == investorToFundManagerPayment.account.owner)

        assertMsg "Actors must include investor" (investor `Set.member` actors)
        -- mergedPaymentCid <-
        --   if length paymentCids == 1 then
        --     pure (L.head paymentCids)
        --   else
        --     exercise (L.head paymentCids) Fungible.Merge with fungibleCids = L.tail paymentCids
        -- splitResult <- exercise mergedPaymentCid Fungible.Split with amounts = [cost, commissionCost]
        -- [investorToFundPaymentCid, investorToFundManagerPaymentCid] <- forA splitResult.splitCids $ \holdingCid -> do
        --   let baseCid : ContractId Holding.Base = toInterfaceContractId holdingCid
        --   exercise baseCid Holding.Acquire with
        --     newLockers = Set.fromList [fund, fundManager, investor]
        --     context = "Investment in fund: " <> show investmentId
        --     lockType = Holding.Semaphore

        let investorToFund = RoutedStep with
              sender = investor
              receiver = fund
              quantity = Quantity with
                unit = paymentInstrument
                amount = cost
              custodian = paymentCustodian
            investorToFundManager = RoutedStep with
              sender = investor
              receiver = fundManager
              quantity = Quantity with
                unit = paymentInstrument
                amount = commissionCost
              custodian = paymentCustodian
            fundToInvestor = RoutedStep with
              sender = fund
              receiver = investor
              quantity = Quantity with
                unit = unitsInstrument
                amount = numUnitsDecimal
              custodian = fund

        let instructors = Set.fromList [fund, fundManager] <> actors
        (batchCid, [investorToFundCid, investorToFundManagerCid, fundToInvestorCid]) <- exercise settlementFactoryCid
          SettlementFactory.Instruct with
            instructors
            settlers = Set.fromList [fund]
            id = investmentId
            description = "Purchase by " <> show investor
            contextId = None
            routedSteps = [investorToFund, investorToFundManager, fundToInvestor]
            settlementTime = None

        -- Investor to fund
        (investorToFundAllocatedCid, _) <- exercise investorToFundCid Instruction.Allocate with
          actors = instructors
          allocation = Pledge investorToFundPaymentCid
        finalInvestorToFundCid <- exercise investorToFundAllocatedCid Instruction.Approve with
          actors = instructors
          approval = TakeDelivery AccountKey with
            owner = fund
            id = fundPaymentAccountId
            custodian = paymentCustodian

        -- Investor to fund manager
        (investorToFundManagerAllocatedCid, _) <- exercise investorToFundManagerCid Instruction.Allocate with
          actors = instructors
          allocation = Pledge investorToFundManagerPaymentCid
        finalInvestorToFundManagerCid <- exercise investorToFundManagerAllocatedCid Instruction.Approve with
          actors = instructors
          approval = TakeDelivery AccountKey with
            owner = fundManager
            id = fundManagerPaymentAccountId
            custodian = paymentCustodian

        -- Fund to investor
        finalFundToInvestorCid <- exercise fundToInvestorCid Instruction.Approve with
          actors = instructors
          approval = TakeDelivery AccountKey with
            owner = investor
            id = investorAccountId
            custodian = fundCustodian

        pure InstructPurchaseResult with
          batchCid
          investorToFundInstructionCid = finalInvestorToFundCid
          investorToFundManagerInstructionCid = finalInvestorToFundManagerCid
          fundToInvestorInstructionCid = finalFundToInvestorCid

-- template FundPurchaseInstruction
--   with
--     fund : Party
--     fundManager : Party
--     investor : Party
--     batchCid : ContractId Batch.I
--   where
--     signatory fund, fundManager, investor

mergeAndSplitHelper : [ContractId Fungible.I] ->
                      Decimal ->
                      Decimal ->
                      Update (ContractId Fungible.I, ContractId Fungible.I, Optional (ContractId Fungible.I))
mergeAndSplitHelper holdingCids amount1 amount2 = do
  mergedHoldingCid <- case holdingCids of
    [] -> error "Cannot merge/split empty holdings" 
    [firstHoldingCid] -> pure firstHoldingCid
    firstHoldingCid :: others -> exercise firstHoldingCid Fungible.Merge with fungibleCids = others
  splitResult <- exercise mergedHoldingCid Fungible.Split with amounts = [amount1, amount2]
  let (holdingCid1, holdingCid2) = case splitResult.splitCids of
        [c1, c2] -> (c1, c2)
        _ -> error "Unexpected list length"
  pure (
      holdingCid1,
      holdingCid2,
      splitResult.rest
    )

template FundInvestor
  with
    investor : Party
    authorisers : Set Party
    investorAccountId : Id
  where
    signatory authorisers

    observer investor

    choice RequestInvestment : InstructPurchaseResult
      with
        numUnits : Int
        paymentCids : [ContractId Fungible.I]
        offerCid : ContractId FundOffer
        investmentId : Id
      controller investor
      do
        offer <- fetch offerCid

        let numUnitsDecimal = intToDecimal numUnits
        (investorToFundPaymentCid, investorToFundManagerPaymentCid, _) <- mergeAndSplitHelper
          paymentCids
          (numUnitsDecimal * offer.costPerUnit)
          (numUnitsDecimal * offer.commission * offer.costPerUnit)

        exercise offerCid InstructPurchase with
          numUnits
          investorToFundPaymentCid = toInterfaceContractId investorToFundPaymentCid
          investorToFundManagerPaymentCid = toInterfaceContractId investorToFundManagerPaymentCid
          actors = Set.insert investor authorisers
          investmentId
          investorAccountId

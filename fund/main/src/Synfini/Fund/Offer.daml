module Synfini.Fund.Offer where

import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import Daml.Finance.Interface.Settlement.Types
import Daml.Finance.Interface.Types.Common.Types
import DA.List ((!!))
import DA.Set (Set)
import qualified DA.Set as Set
import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import qualified Daml.Finance.Interface.Settlement.Batch as Batch
import Synfini.Tokenization.Util

template FundOffer
  with
    fund : Party
    fundManager : Party
    fundCustodian : Party -- Custodian at which fund units are held (can also be the fund)
    unitsInstrument : InstrumentKey
    paymentInstrument : InstrumentKey
    costPerUnit : Decimal
    commission : Decimal
    minInvesment : Decimal -- Minimum investment amount (measured in units of the payment instrument, not including
    -- commission fees)
    fundPaymentAccountId : Id -- Account where fund receives payments
    fundManagerPaymentAccountId : Id -- Account where fund manager receives commissions
    paymentCustodian : Party -- Custodian at which all payment assets must be held
    settlementFactoryCid : ContractId SettlementFactory.I
    observers : Set Party
  where
    signatory fund, fundCustodian, fundManager -- In practice these parties may be the same

    observer observers

    ensure commission > 0.0 && costPerUnit > 0.0 && minInvesment > 0.0

    nonconsuming choice GetFundOfferPayload : FundOffer
      with
        viewer : Party
      controller viewer
      do
        pure this

    nonconsuming choice InstructPurchase : ContractId FundPurchaseInstruction
      with
        numUnits : Int
        investorToFundPaymentCid : ContractId Holding.I
        investorToFundManagerPaymentCid : ContractId Holding.I
        actors : Set Party
        investorAccountId: Id
        investmentId : Id
      controller actors
      do
        let numUnitsDecimal = intToDecimal numUnits
        let cost = numUnitsDecimal * costPerUnit
        let commissionCost = cost * commission

        assertMsg "Must invest minimum amount" (cost >= minInvesment)

        investorToFundPayment <- view <$> (fetch investorToFundPaymentCid)
        investorToFundManagerPayment <- view <$> (fetch investorToFundManagerPaymentCid)

        let investor = investorToFundPayment.account.owner
        assertMsg
          "Both payments must come from the same investor"
          (investor == investorToFundManagerPayment.account.owner)

        assertMsg "Actors must include investor" (investor `Set.member` actors)

        let investorToFund = RoutedStep with
              sender = investor
              receiver = fund
              quantity = Quantity with
                unit = paymentInstrument
                amount = cost
              custodian = paymentCustodian
            investorToFundManager = RoutedStep with
              sender = investor
              receiver = fundManager
              quantity = Quantity with
                unit = paymentInstrument
                amount = commissionCost
              custodian = paymentCustodian
            fundToInvestor = RoutedStep with
              sender = fund
              receiver = investor
              quantity = Quantity with
                unit = unitsInstrument
                amount = numUnitsDecimal
              custodian = fundCustodian

        let instructors = Set.fromList [fund, fundManager, fundCustodian] <> actors
        (batchCid, [investorToFundCid, investorToFundManagerCid, fundToInvestorCid]) <- exercise settlementFactoryCid
          SettlementFactory.Instruct with
            instructors
            settlers = Set.fromList [fund]
            id = investmentId
            description = "Purchase by " <> show investor
            contextId = None
            routedSteps = [investorToFund, investorToFundManager, fundToInvestor]
            settlementTime = None

        -- Investor to fund
        (investorToFundAllocatedCid, _) <- exercise investorToFundCid Instruction.Allocate with
          actors = instructors
          allocation = Pledge investorToFundPaymentCid
        finalInvestorToFundCid <- exercise investorToFundAllocatedCid Instruction.Approve with
          actors = instructors
          approval = TakeDelivery AccountKey with
            owner = fund
            id = fundPaymentAccountId
            custodian = paymentCustodian

        -- Investor to fund manager
        (investorToFundManagerAllocatedCid, _) <- exercise investorToFundManagerCid Instruction.Allocate with
          actors = instructors
          allocation = Pledge investorToFundManagerPaymentCid
        finalInvestorToFundManagerCid <- exercise investorToFundManagerAllocatedCid Instruction.Approve with
          actors = instructors
          approval = TakeDelivery AccountKey with
            owner = fundManager
            id = fundManagerPaymentAccountId
            custodian = paymentCustodian

        -- Fund to investor
        finalFundToInvestorCid <- exercise fundToInvestorCid Instruction.Approve with
          actors = instructors
          approval = TakeDelivery AccountKey with
            owner = investor
            id = investorAccountId
            custodian = fundCustodian

        create FundPurchaseInstruction with
          fund
          fundManager
          investor
          investmentId
          instructors
          unitsInstrument
          numUnits
          batchCid
          fundToInvestorInstructionCid = finalFundToInvestorCid

data AcceptPurchaseInstructionResult = AcceptPurchaseInstructionResult
  with
    fundHoldingCid : ContractId Holding.I
    fundManagerHoldingCid : ContractId Holding.I
    investorHoldingCid : ContractId Holding.I
  deriving (Show, Eq)

template FundPurchaseInstruction
  with
    fund : Party
    fundManager : Party
    investor : Party
    investmentId : Id
    instructors : Set Party
    unitsInstrument : InstrumentKey
    numUnits : Int
    batchCid : ContractId Batch.I
    fundToInvestorInstructionCid : ContractId Instruction.I
  where
    signatory instructors

    key (fund, investmentId) : (Party, Id)
    maintainer key._1

    ensure Set.fromList [fund, fundManager, investor] `Set.isSubsetOf` instructors

    choice GetFundPurchaseInstructionPayload : FundPurchaseInstruction
      with
        viewer : Party
      controller viewer
      do
        pure this

    choice RejectPurchaseInstruction : ()
      controller fund
      do
        exercise batchCid Batch.Cancel with actors = instructors
        pure ()

    choice AcceptPurchaseInstruction : AcceptPurchaseInstructionResult
      with
        allocation : Allocation
      controller fund
      do
        exercise fundToInvestorInstructionCid Instruction.Allocate with allocation, actors = instructors
        [fundHoldingCid, fundManagerHoldingCid, investorHoldingCid] <- exercise
          batchCid
          Batch.Settle with actors = instructors
        pure AcceptPurchaseInstructionResult with fundHoldingCid, fundManagerHoldingCid, investorHoldingCid

template AcceptPurchaseInstructionHelper
  with
    fund : Party
  where
    signatory fund

    choice AcceptPurchaseInstructionFromFungibles : AcceptPurchaseInstructionResult
      with
        allocationCids : [ContractId Fungible.I]
        investmentId : Id
      controller fund
      do
        let instructionKey = (fund, investmentId)
        (_, purchaseInstruction) <- fetchByKey @FundPurchaseInstruction (fund, investmentId)
        batch <- exercise purchaseInstruction.batchCid Batch.GetView with viewer = fund
        (allocationCid, _) <- mergeAndSplitHelper1 allocationCids ((batch.routedSteps !! 2).quantity.amount)
        exerciseByKey @FundPurchaseInstruction instructionKey AcceptPurchaseInstruction with
          allocation = Pledge (toInterfaceContractId allocationCid)

template FundInvestor
  with
    investor : Party
    authorisers : Set Party
    investorAccountId : Id
  where
    signatory authorisers

    observer investor

    choice RequestInvestment : ContractId FundPurchaseInstruction
      with
        numUnits : Int
        paymentCids : [ContractId Fungible.I]
        offerCid : ContractId FundOffer
        investmentId : Id
      controller investor
      do
        offer <- exercise offerCid GetFundOfferPayload with viewer = investor

        let numUnitsDecimal = intToDecimal numUnits
        (investorToFundPaymentCid, investorToFundManagerPaymentCid, _) <- mergeAndSplitHelper2
          paymentCids
          (numUnitsDecimal * offer.costPerUnit)
          (numUnitsDecimal * offer.commission * offer.costPerUnit)

        exercise offerCid InstructPurchase with
          numUnits
          investorToFundPaymentCid = toInterfaceContractId investorToFundPaymentCid
          investorToFundManagerPaymentCid = toInterfaceContractId investorToFundManagerPaymentCid
          actors = Set.insert investor authorisers
          investmentId
          investorAccountId

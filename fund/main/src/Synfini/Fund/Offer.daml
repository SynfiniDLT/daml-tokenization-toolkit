module Synfini.Fund.Offer where

import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import Daml.Finance.Interface.Settlement.Types
import Daml.Finance.Interface.Types.Common.Types
import DA.Set (Set)
import qualified DA.Set as Set
import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import qualified DA.List as L
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import qualified Daml.Finance.Interface.Settlement.Batch as Batch

data InstructPurchaseResult = InstructPurchaseResult
  with
    batchCid : ContractId Batch.I
    investorToFundInstructionCid : ContractId Instruction.I
    investorToFundManagerInstructionCid : ContractId Instruction.I
    fundToInvestorInstructionCid : ContractId Instruction.I
  deriving (Show, Eq)

template FundOffer
  with
    fund : Party
    fundManager : Party
    fundCustodian : Party -- Custodian at which fund units are held (can also be the fund)
    unitsInstrument : InstrumentKey
    paymentInstrument : InstrumentKey
    costPerUnit : Decimal
    commission : Decimal
    minInvesment : Decimal -- Minimum investment amount (measured in units of the payment instrument, not including
    -- commission fees)
    fundPaymentAccountId : Id -- Account where fund receives payments
    fundManagerPaymentAccountId : Id -- Account where fund manager receives commissions
    paymentCustodian : Party -- Custodian at which all payment assets must be held
    settlementFactoryCid : ContractId SettlementFactory.I
    observers : Set Party
  where
    signatory fund, fundCustodian -- In practice these parties may be the same

    observer fundManager, observers

    ensure commission >= 0.0 && commission <= 1.0 && costPerUnit > 0.0 && minInvesment > 0.0

    nonconsuming choice InstructPurchase : InstructPurchaseResult
      with
        numUnits : Int
        paymentCids : [ContractId Fungible.I]
        investor : Party
        investorAccountId: Id
        investmentId : Id
      controller investor, fundManager
      do
        let numUnitsDecimal = intToDecimal numUnits
        let cost = numUnitsDecimal * costPerUnit
        let commissionCost = cost * commission

        assertMsg "Must invest minimum amount" (cost >= minInvesment)

        mergedPaymentCid <-
          if length paymentCids == 1 then
            pure (L.head paymentCids)
          else
            exercise (L.head paymentCids) Fungible.Merge with fungibleCids = L.tail paymentCids
        splitResult <- exercise mergedPaymentCid Fungible.Split with amounts = [cost, commissionCost]
        [investorToFundPaymentCid, investorToFundManagerPaymentCid] <- forA splitResult.splitCids $ \holdingCid -> do
          let baseCid : ContractId Holding.Base = toInterfaceContractId holdingCid
          exercise baseCid Holding.Acquire with
            newLockers = Set.fromList [fund, fundManager, investor]
            context = "Investment in fund: " <> show investmentId
            lockType = Holding.Semaphore

        let investorToFund = RoutedStep with
              sender = investor
              receiver = fund
              quantity = Quantity with
                unit = paymentInstrument
                amount = cost
              custodian = paymentCustodian
            investorToFundManager = RoutedStep with
              sender = investor
              receiver = fundManager
              quantity = Quantity with
                unit = paymentInstrument
                amount = commissionCost
              custodian = paymentCustodian
            fundToInvestor = RoutedStep with
              sender = fund
              receiver = investor
              quantity = Quantity with
                unit = unitsInstrument
                amount = numUnitsDecimal
              custodian = fund

        (batchCid, [investorToFundCid, investorToFundManagerCid, fundToInvestorCid]) <- exercise settlementFactoryCid
          SettlementFactory.Instruct with
            instructors = Set.fromList [fund]
            settlers = Set.fromList [fund]
            id = investmentId
            description = "Purchase by " <> show investor
            contextId = None
            routedSteps = [investorToFund, investorToFundManager, fundToInvestor]
            settlementTime = None

        -- Investor to fund
        (investorToFundAllocatedCid, _) <- exercise investorToFundCid Instruction.Allocate with
          actors = Set.fromList [investor, fund, fundManager]
          allocation = Pledge investorToFundPaymentCid
        finalInvestorToFundCid <- exercise investorToFundAllocatedCid Instruction.Approve with
          actors = Set.fromList [fund]
          approval = TakeDelivery AccountKey with
            owner = fund
            id = fundPaymentAccountId
            custodian = paymentCustodian

        -- Investor to fund manager
        (investorToFundManagerAllocatedCid, _) <- exercise investorToFundManagerCid Instruction.Allocate with
          actors = Set.fromList [investor, fund, fundManager]
          allocation = Pledge investorToFundManagerPaymentCid
        finalInvestorToFundManagerCid <- exercise investorToFundManagerAllocatedCid Instruction.Approve with
          actors = Set.fromList [fundManager]
          approval = TakeDelivery AccountKey with
            owner = fundManager
            id = fundManagerPaymentAccountId
            custodian = paymentCustodian

        -- Fund to investor
        finalFundToInvestorCid <- exercise fundToInvestorCid Instruction.Approve with
          actors = Set.fromList [investor, fundCustodian]
          approval = TakeDelivery AccountKey with
            owner = investor
            id = investorAccountId
            custodian = fundCustodian

        pure InstructPurchaseResult with
          batchCid
          investorToFundInstructionCid = finalInvestorToFundCid
          investorToFundManagerInstructionCid = finalInvestorToFundManagerCid
          fundToInvestorInstructionCid = finalFundToInvestorCid

module Synfini.Mint.Test where

import qualified Daml.Finance.Interface.Account.Account as Account
import qualified Daml.Finance.Interface.Account.Factory as Account
import Daml.Finance.Interface.Types.Common.Types
import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Holding.Factory as Holding
import qualified Daml.Finance.Interface.Settlement.Factory as Settlement

import qualified Daml.Finance.Account.Account as AccountImpl
import qualified Daml.Finance.Holding.Fungible as FungibleImpl
import qualified Daml.Finance.Settlement.Factory as SettlementImpl

import Daml.Script
import qualified DA.Map as Map
import qualified DA.Set as Set
import Synfini.Mint

_supplyAccountId : Id
_supplyAccountId = Id "supply"

aliceAccountId : Id
aliceAccountId = Id "0"

aliceAccount : Setup -> AccountKey
aliceAccount s = AccountKey with custodian = s.custodian, owner = s.alice, id = aliceAccountId

data Setup = Setup
  with
    public : Party
    custodian : Party
    issuer : Party
    depository : Party
    minterBurner : Party
    serviceProvider : Party
    alice : Party
    mintCid : ContractId Mint
  deriving (Show, Eq)

doSetup : Script Setup
doSetup = do
  public <- allocateParty "public"
  custodian <- allocateParty "custodian"
  issuer <- allocateParty "issuer"
  depository <- allocateParty "depository"
  minterBurner <- allocateParty "minterBurner"
  serviceProvider <- allocateParty "serviceProvider"
  alice <- allocateParty "alice"

  holdingFactoryCid : ContractId Holding.Factory <- fmap toInterfaceContractId . submit custodian $
    createCmd FungibleImpl.Factory with
      provider = custodian
      observers = Map.fromList [("public", Set.fromList [public])]
  accountFactoryCid : ContractId Account.Factory <- fmap toInterfaceContractId . submit custodian $
    createCmd AccountImpl.Factory with
      provider = custodian
      observers = Map.fromList [("public", Set.fromList [public])]
  settlementFactoryCid : ContractId Settlement.Factory <- fmap toInterfaceContractId . submit custodian $
    createCmd SettlementImpl.Factory with
      provider = custodian
      observers = Set.fromList [public]

  let supplyAccount = AccountKey with
        custodian
        owner = minterBurner
        id = _supplyAccountId
  submitMulti [custodian, minterBurner] [] $ exerciseCmd accountFactoryCid Account.Create with
    account = supplyAccount
    controllers = Account.Controllers with
      incoming = Set.fromList [custodian, minterBurner]
      outgoing = Set.fromList [custodian, minterBurner]
    holdingFactoryCid
    description = "Supply account"
    observers = Map.fromList [("public", Set.fromList [public])]

  let aliceAccount = AccountKey with
        custodian
        owner = alice
        id = aliceAccountId
  submitMulti [custodian, alice] [] $ exerciseCmd accountFactoryCid Account.Create with
    account = aliceAccount
    controllers = Account.Controllers with
      incoming = Set.fromList [serviceProvider]
      outgoing = Set.fromList [serviceProvider, alice]
    holdingFactoryCid
    description = "Alice's account"
    observers = Map.fromList [("Issuer", Set.fromList [minterBurner])]

  let instrument = InstrumentKey with
        issuer
        depository
        id = Id "MyCoin"
        version = "0"

  mintCid <- submitMulti [custodian, issuer, minterBurner, serviceProvider] [] $ createCmd Mint with
    custodian
    minterBurner = minterBurner
    receiverAuthorisers = Set.fromList [serviceProvider]
    supplyAccountId = supplyAccount.id
    instrument
    settlementFactoryCid
    observers = Set.fromList [public]

  pure Setup with ..

withSetup : (Setup -> Script a) -> Script ()
withSetup test = do
  s <- doSetup
  test s
  pure ()

instructMint : Setup -> Party -> Party -> Id -> Decimal -> Id -> Script (ContractId MintInstruction)
instructMint setup instructor receiver receiverAccountId amount id = do
  submitMulti [instructor] [setup.public] $ exerciseCmd setup.mintCid InstructMint with
    instructor
    receiver
    receiverAccountId
    amount
    id
    description = "description"

test_instructMint : Script ()
test_instructMint = pure () -- TODO

test_rejectMint : Script ()
test_rejectMint = withSetup $ \setup -> do
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId 99.9 (Id "ref1")
  submitMultiMustFail [setup.custodian] [setup.public] $ exerciseCmd mintInstructionCid RejectMint
  submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid RejectMint
  activeInstructions <- query @MintInstruction setup.alice
  assertMsg "Instructions must be empty" (null activeInstructions)

test_acceptMint : Script ()
test_acceptMint = withSetup $ \setup -> do
  let amount = 99.9
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId amount (Id "ref1")
  submitMultiMustFail [setup.custodian] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint
  mintResult <- submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint
  [(aliceHoldingCid, Some aliceHolding)] <- queryInterface @Holding.I setup.alice
  assertMsg "Reciever must have correct contract ID" (aliceHoldingCid == mintResult.receiverHoldingCid)
  assertMsg "Receiver must have correct amount" (aliceHolding.amount == amount)
  [(minterBurnerHoldingCid, Some minterBurnerHolding)] <- queryInterface @Holding.I setup.minterBurner
  assertMsg "Minter/burner must have correct contract ID" (minterBurnerHoldingCid == mintResult.supplyHoldingCid)
  assertMsg "Minter/burner must have correct amount" (minterBurnerHolding.amount == amount)

test_instructBurn : Script ()
test_instructBurn = pure () -- TODO

test_rejectBurn : Script ()
test_rejectBurn = withSetup $ \setup -> do
  mintInstructionCid <- instructMint setup setup.alice setup.alice aliceAccountId 99.9 (Id "ref1")
  mintResult <- submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd mintInstructionCid ExecuteMint
  burnInstructionCid <- submitMulti [setup.alice] [setup.public] $ exerciseCmd setup.mintCid InstructBurn with
    instructor = setup.alice
    holdingCid = mintResult.receiverHoldingCid
    id = Id "ref2"
    description = "Burn"
  submitMultiMustFail [setup.custodian] [setup.public] $ exerciseCmd burnInstructionCid RejectBurn
  submitMulti [setup.minterBurner] [setup.public] $ exerciseCmd burnInstructionCid RejectBurn
  activeInstructions <- query @BurnInstruction setup.alice
  assertMsg "Instructions must be empty" (null activeInstructions)

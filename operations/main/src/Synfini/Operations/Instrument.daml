module Synfini.Operations.Instrument where

import Synfini.Operations.Types
import Synfini.Operations.Issuer (Issuer(..), MetadataPublisher(..))

import qualified Synfini.Interface.Instrument.Metadata.Metadata as Metadata
import Daml.Script
import qualified Synfini.Interface.Onboarding.Issuer.Instrument.Token.Issuer as TokenIssuer
import Daml.Finance.Interface.Instrument.Token.Types (Token(..))
import qualified DA.Set as Set
import Daml.Finance.Interface.Types.Common.Types
import qualified DA.Text as TX
import qualified DA.List as L
import qualified Synfini.Interface.Onboarding.Issuer.Metadata.Publisher as Publisher
import qualified DA.Map as Map
import qualified DA.Functor as F

data AttributeSettings = AttributeSettings
  with
    attributeName : Text
    attributeValue : Text
    displayType : Text

toAttributes : [AttributeSettings] -> Metadata.Attributes
toAttributes attrs = Map.fromList $
  (\AttributeSettings { attributeName, attributeValue, displayType } ->
    (attributeName, Metadata.Attribute with attributeValue, displayType)
  ) <$> attrs

data MetadataSettings = MetadataSettings
  with
    publisher : Text
    attributes : [AttributeSettings]
    disclosureControllers : [Text]
    observers : [Observer]

data InstrumentSettings = InstrumentSettings
  with
    issuer : Text
    id : Text
    version : Optional Text
    description : Text
    validAsOf : Time
    observers : [Observer]
    metadata : Optional MetadataSettings

data CreateInstrumentsInput = CreateInstrumentsInput
  with
    readAs : [Text]
    parties : [PartyInfo]
    issuers : [Issuer]
    instrumentMetadataPublishers : [MetadataPublisher]
    instrumentSettings : [InstrumentSettings]

getOrCalculateVersion : Optional MetadataSettings -> Optional Text -> Text
getOrCalculateVersion None None = error "Please provide at least one of 'metadata' or 'version'"
getOrCalculateVersion _ (Some v) = v
getOrCalculateVersion (Some MetadataSettings { attributes }) None =
  let hashedAttributes = hashAttribute <$> attributes in
  TX.sha256 (mconcat $ L.sort hashedAttributes)

  where
    hashAttribute AttributeSettings { attributeName, attributeValue, displayType } = TX.sha256 $
      mconcat (TX.sha256 <$> [attributeName, attributeValue, displayType])

createInstruments : CreateInstrumentsInput -> Script ()
createInstruments input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  let readAs = p <$> input.readAs
  let cmd InstrumentSettings { issuer, id, version, description, validAsOf, observers, metadata } =
        let iss = findByLabel issuer input.issuers
            v = getOrCalculateVersion metadata version
        in
        let instrumentCmd = case iss.instrumentType of
              "Token" -> do
                let tokenIssuerCid : ContractId TokenIssuer.I = coerceContractId iss.cid
                F.void $ exerciseCmd tokenIssuerCid TokenIssuer.CreateInstrument with
                  token = Token with
                    instrument = InstrumentKey with
                      issuer = iss.issuer
                      depository = iss.depository
                      id = Id id
                      version = v
                    description
                    validAsOf
                  observers = asPartiesMap p observers
              other -> error ("Unsupported instrument type: " <> other)
            metadataCmd = case metadata of
              None -> []
              Some m ->
                let publisher = findByLabel m.publisher input.instrumentMetadataPublishers in
                if publisher.issuer /= iss.issuer || publisher.depository /= iss.issuer then
                  error "Publisher does not have matching issuer and/or depository"
                else
                  pure . F.void $ exerciseCmd publisher.cid Publisher.PublishMetadata with
                    id = Id id
                    version = v
                    attributes = toAttributes m.attributes
                    disclosureControllers = Set.fromList (p <$> m.disclosureControllers)
                    observers = asPartiesMap p m.observers
        in
        (iss.issuer, sequence $ instrumentCmd :: metadataCmd)
  let cmds = cmd <$> input.instrumentSettings
  let actAs = L.dedup $ fst <$> cmds
  submitMulti actAs readAs (sequence $ snd <$> cmds)
  pure ()

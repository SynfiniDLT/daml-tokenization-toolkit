{-# LANGUAGE ApplicativeDo #-}
module Synfini.Operations.PartyBoundAttributes.Unilateral where

import qualified Synfini.Interface.Instrument.PartyBoundAttributes.Factory as Pba
import Synfini.Operations.Factory.Instrument
import Synfini.Operations.Factory.Settlement
import DA.Map (Map)
import Synfini.Operations.Types
import Daml.Script
import qualified DA.Set as Set
import Daml.Finance.Interface.Settlement.Types
import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import Daml.Finance.Interface.Types.Common.Types
import DA.Foldable (forA_)
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import qualified Daml.Finance.Interface.Settlement.Batch as Batch
import qualified Daml.Finance.Interface.Util.Disclosure as Disclosure
import qualified DA.Text as TX

data PbaSettings = PbaSettings
  with
    version : Text
    validAsOf : Time
    owner : Text
    accountId : Text
    attributes : Map Text Text
    instrumentObservers : [Observer]
    holdingObservers : [Observer]

data PbaInstrument = PbaInstrument
  with
    depository : Text
    issuer : Text
    id : Text
    description : Text
    custodian : Text

data CreatePbasInput = CreatePbasInput
  with
    parties : [PartyInfo]
    readAs : [Text]
    instrumentFactories : [InstrumentFactory]
    settlementFactories : [SettlementFactory]
    instrumentFactory : Text
    settlementFactory : Text
    pbaInstrument : PbaInstrument
    pbas : [PbaSettings]

createPbas : CreatePbasInput -> Script ()
createPbas input = do
  let pm = partyTable input.parties
  let p = getPartyId pm
  let custodian = p input.pbaInstrument.custodian
      issuer = p input.pbaInstrument.issuer
      depository = p input.pbaInstrument.depository
      readAs = p <$> input.readAs
      instrumentFactoryCid : ContractId Pba.Factory = coerceContractId $
        findFactoryContractId input.instrumentFactory input.instrumentFactories
      settlementFactoryCid = findFactoryContractId input.settlementFactory input.settlementFactories
  forA_ input.pbas $ \pba -> do
    t <- getTime
    let instrument = InstrumentKey with depository, issuer, id = Id input.pbaInstrument.id, version = pba.version
    let owner = p pba.owner
    let account = AccountKey with custodian, owner, id = Id pba.accountId
    let step = RoutedStep with
          sender = custodian
          receiver = owner
          custodian
          quantity = Quantity with
            unit = instrument
            amount = 1.0
        batchId = Id (TX.sha256 $ show instrument <> show t)
    (batchCid, [instructionCid]) <- submitMulti [custodian] readAs do
      exerciseCmd settlementFactoryCid SettlementFactory.Instruct with
        instructors = Set.fromList [custodian]
        id = batchId
        settlers = Set.fromList [custodian]
        description = "Creation of party-bound token"
        contextId = None
        routedSteps = [step]
        settlementTime = None
    (instructionCid, _) <- submitMulti [custodian] readAs do
      exerciseCmd instructionCid Instruction.Allocate with
        actors = Set.fromList [custodian], allocation = CreditReceiver
    submitMulti [custodian] readAs do
      exerciseCmd instructionCid Instruction.Approve with
        actors = Set.fromList [custodian], approval = TakeDelivery account
    [pbaHoldingCid] <- submitMulti [custodian, issuer, depository] readAs do
      exerciseCmd instrumentFactoryCid Pba.Create with
        instrument
        description = input.pbaInstrument.description
        validAsOf = pba.validAsOf
        owner
        attributes = pba.attributes
        observers = asPartiesMap p pba.instrumentObservers
      cids <- exerciseCmd batchCid Batch.Settle with actors = Set.fromList [custodian]
      pure cids
    let disclosableHoldingCid : ContractId Disclosure.I = toInterfaceContractId pbaHoldingCid
    submit custodian do
      exerciseCmd disclosableHoldingCid Disclosure.SetObservers with
        disclosers = Set.fromList [custodian]
        newObservers = asPartiesMap p pba.holdingObservers
    pure ()

module Synfini.Mint where

import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Holding.Fungible as Fungible
import qualified Daml.Finance.Interface.Settlement.Batch as Batch
import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types
import qualified DA.List.Total as List
import qualified DA.Optional as O
import DA.Set (Set)
import qualified DA.Set as Set

template Mint
  with
    custodian : Party
    receiverAuthorisers : Set Party
    minterBurner : Party
    supplyAccountId : Id
    instrument : InstrumentKey
    settlementFactoryCid : ContractId SettlementFactory.I
    observers : Set Party
  where
    signatory custodian, minterBurner, receiverAuthorisers

    observer observers

    nonconsuming choice InstructMint : ContractId MintInstruction
      with
        instructor : Party
        receiver : Party
        receiverAccountId : Id
        amount : Decimal
        id : Id
        description : Text
      controller instructor
      do
        assertMsg "Requestor must be owner or minter" (instructor == receiver || instructor == minterBurner)

        let allActors = Set.fromList [custodian, instructor] <> receiverAuthorisers
            onlyCustodian = Set.fromList [custodian]
            quantity = Quantity with unit = instrument, amount
        let custodianToOwner = RoutedStep with
              custodian
              sender = custodian
              receiver
              quantity
            custodianToMb = RoutedStep with
              custodian
              sender = custodian
              receiver = minterBurner
              quantity
        (batchCid, [custodianToOwnerCid, custodianToMbCid]) <- exercise
          settlementFactoryCid
          SettlementFactory.Instruct with
            instructors = allActors
            settlers = Set.fromList [minterBurner]
            id
            description
            contextId = None
            routedSteps = [custodianToOwner, custodianToMb]
            settlementTime = None

        (allocatedCustodianToOwnerCid, _) <- exercise custodianToOwnerCid Instruction.Allocate with
          actors = onlyCustodian
          allocation = CreditReceiver
        approvedCustodianToOwnerCid <- exercise allocatedCustodianToOwnerCid Instruction.Approve with
          actors = onlyCustodian <> receiverAuthorisers
          approval = TakeDelivery (AccountKey with custodian, owner = receiver, id = receiverAccountId)

        (allocatedCustodianToMbCid, _) <- exercise custodianToMbCid Instruction.Allocate with
          actors = onlyCustodian
          allocation = CreditReceiver
        exercise allocatedCustodianToMbCid Instruction.Approve with
          actors = Set.fromList [custodian, minterBurner]
          approval = TakeDelivery (AccountKey with custodian, owner = minterBurner, id = supplyAccountId)

        create MintInstruction with
          custodian
          minterBurner
          requestors = allActors
          batchCid

    nonconsuming choice InstructBurn : ContractId BurnInstruction
      with
        instructor : Party
        holdingCid : ContractId Holding.I
        id : Id
        description : Text
      controller instructor
      do
        holdingView <- exercise holdingCid Holding.GetView with viewer = instructor
        assertMsg "Requestor must be the owner" (holdingView.account.owner == instructor)
        assertMsg "Must have expected instrument" (holdingView.instrument == instrument)
        assertMsg "Must have expected custodian" (holdingView.account.custodian == custodian)

        let allActors = Set.fromList [custodian, instructor] <> receiverAuthorisers
            onlyCustodian = Set.fromList [custodian]
            quantity = Quantity with unit = holdingView.instrument, amount = holdingView.amount
        let ownerToCustodian = RoutedStep with
              custodian
              sender = holdingView.account.owner
              receiver = custodian
              quantity
            mbToCustodian = RoutedStep with
              custodian
              sender = minterBurner
              receiver = custodian
              quantity
        (batchCid, [ownerToCustodianCid, mbToCustodianCid]) <- exercise
          settlementFactoryCid
          SettlementFactory.Instruct with
            instructors = allActors
            settlers = Set.fromList [minterBurner]
            id
            description
            contextId = None
            routedSteps = [ownerToCustodian, mbToCustodian]
            settlementTime = None

        (allocatedOwnerToCustodianCid, _) <- exercise ownerToCustodianCid Instruction.Allocate with
          actors = allActors
          allocation = Pledge holdingCid

        -- TODO is the holding lock check needed?
        -- Pledge lockedHoldingCid <- (.allocation) <$> exercise allocatedOwnerToCustodianCid Instruction.GetView with
        --   viewer = instructor
        -- lockedHolding <- exercise lockedHoldingCid Holding.GetView with viewer = instructor
        -- let lockOpt = lockedHolding.lock
        -- assertMsg "Holding must have lock" (isSome lockOpt)
        -- let (Some lock) = lockOpt
        -- assertMsg "Holding must be locked by custodian" (Set.member custodian lock.lockers)

        approvedOwnerToCustodianCid <- exercise allocatedOwnerToCustodianCid Instruction.Approve with
          actors = onlyCustodian
          approval = DebitSender

        approvedMbToCustodianCid <- exercise mbToCustodianCid Instruction.Approve with
          actors = onlyCustodian
          approval = DebitSender

        create BurnInstruction with
          custodian
          minterBurner
          supplyAccountId
          quantity = Quantity with unit = instrument, amount = holdingView.amount
          requestors = allActors
          batchCid
          supplyInstructionCid = approvedMbToCustodianCid
          isAllocated = False

data ExecuteMintResult = ExecuteMintResult
  with
    receiverHoldingCid : ContractId Holding.I
    supplyHoldingCid : ContractId Holding.I
  deriving (Show, Eq)

template MintInstruction
  with
    custodian : Party
    minterBurner : Party
    requestors : Set Party
    batchCid : ContractId Batch.I
  where
    signatory custodian, minterBurner, requestors

    choice ExecuteMint : ExecuteMintResult
      controller minterBurner
      do
        [receiverHoldingCid, supplyHoldingCid] <- exercise batchCid Batch.Settle with
          actors = Set.fromList [minterBurner]
        pure ExecuteMintResult with receiverHoldingCid, supplyHoldingCid

    choice RejectMint : [ContractId Holding.I]
      controller minterBurner
      do
        exercise batchCid Batch.Cancel with actors = Set.insert minterBurner requestors

template BurnInstruction
  with
    custodian : Party
    minterBurner : Party
    requestors : Set Party
    supplyAccountId : Id
    quantity : Quantity InstrumentKey Decimal
    batchCid : ContractId Batch.I
    supplyInstructionCid : ContractId Instruction.I
    isAllocated : Bool
  where
    signatory custodian, minterBurner, requestors

    choice ExecuteBurn : ()
      controller minterBurner
      do
        exercise batchCid Batch.Settle with actors = Set.fromList [minterBurner]
        pure ()

    choice AllocateBurnSupply : ContractId BurnInstruction
      with
        holdingCid : ContractId Holding.I
      controller minterBurner
      do
        holding <- exercise holdingCid Holding.GetView with viewer = minterBurner
        assertMsg "Holding must be from supply account" (holding.account.id == supplyAccountId)
        (newSupplyInstructionCid, _) <- exercise supplyInstructionCid Instruction.Allocate with
          actors = Set.fromList [custodian, minterBurner]
          allocation = Pledge holdingCid
        create this with supplyInstructionCid = newSupplyInstructionCid, isAllocated = True

    choice RejectBurn : [ContractId Holding.I]
      controller minterBurner
      do
        exercise batchCid Batch.Cancel with actors = Set.insert minterBurner requestors

data AllocateBurnSupplyFromHoldingsResult = AllocateBurnSupplyFromHoldingsResult
  with
    burnInstructionCid : ContractId BurnInstruction
    allocatedHoldingCid : ContractId Fungible.I
    otherHoldingCid : Optional (ContractId Fungible.I)
  deriving (Show, Eq)

template AllocateBurnSupplyHelper
  with
    minterBurner : Party
  where
    signatory minterBurner

    choice AllocateBurnSupplyFromHoldings : AllocateBurnSupplyFromHoldingsResult
      with
        burnInstructionCid : ContractId BurnInstruction
        holdingCids : [ContractId Fungible.I]
      controller minterBurner
      do
        burnInstruction <- fetch burnInstructionCid
        mergedHoldingCid <- case holdingCids of
          [] -> error "Holdings list cannot be empty" 
          [firstHoldingCid] -> pure firstHoldingCid
          firstHoldingCid :: others -> exercise firstHoldingCid Fungible.Merge with fungibleCids = others
        splitResult <- exercise mergedHoldingCid Fungible.Split with amounts = [burnInstruction.quantity.amount]
        let holdingCidToAllocate = O.fromSomeNote "Unexpected empty list" (List.head splitResult.splitCids)
        burnInstructionCid' <- exercise burnInstructionCid AllocateBurnSupply with holdingCid = toInterfaceContractId holdingCidToAllocate
        pure AllocateBurnSupplyFromHoldingsResult with
          burnInstructionCid = burnInstructionCid'
          allocatedHoldingCid = holdingCidToAllocate
          otherHoldingCid = splitResult.rest

module Synfini.Mint where

import qualified Daml.Finance.Interface.Holding.Base as Holding
import qualified Daml.Finance.Interface.Settlement.Batch as Batch
import qualified Daml.Finance.Interface.Settlement.Factory as SettlementFactory
import qualified Daml.Finance.Interface.Settlement.Instruction as Instruction
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), RoutedStep(..))
import Daml.Finance.Interface.Types.Common.Types
import DA.Optional (isSome)
import DA.Set (Set)
import qualified DA.Set as Set

displayInstrument : InstrumentKey -> Text
displayInstrument instrument =
  show instrument.id <>
  " (version: " <> instrument.version <>
  ", issuer: " <> show instrument.issuer  <>
  ", depository: " <> show instrument.depository <> ")" 

data MintRequestResult = MintRequestResult
  with
    batchCid : ContractId Batch.I
    takeDeliveryDelegationCid : ContractId TakeDeliveryDelegation
  deriving (Show, Eq)

data BurnRequestResult = BurnRequestResult
  with
    batchCid : ContractId Batch.I
    pledgeDelegationCid : ContractId PledgeDelegation
  deriving (Show, Eq)

template Mint
  with
    custodian : Party
    receiverAuthorisers : Set Party
    minterBurner : Party
    supplyAccountId : Id
    instrument : InstrumentKey
    settlementFactoryCid : ContractId SettlementFactory.I
    observers : Set Party
  where
    signatory custodian, receiverAuthorisers

    observer observers

    nonconsuming choice RequestMint : MintRequestResult
      with
        requestor : Party
        account : AccountKey
        amount : Decimal
        id : Id
      controller requestor
      do
        assertMsg "Account must have expected custodian" (account.custodian == custodian)
        assertMsg "Requestor must be owner or minter" (requestor == account.owner || requestor == minterBurner)

        let allActors = Set.fromList [custodian, requestor] <> receiverAuthorisers
            onlyCustodian = Set.fromList [custodian]
            quantity = Quantity with unit = instrument, amount
        let custodianToOwner = RoutedStep with
              custodian
              sender = custodian
              receiver = account.owner
              quantity
            custodianToMb = RoutedStep with
              custodian
              sender = custodian
              receiver = minterBurner
              quantity
        (batchCid, [custodianToOwnerCid, custodianToMbCid]) <- exercise
          settlementFactoryCid
          SettlementFactory.Instruct with
            instructors = allActors
            settlers = Set.fromList [minterBurner]
            id
            description = "Mint: " <> displayInstrument instrument
            contextId = None
            routedSteps = [custodianToOwner, custodianToMb]
            settlementTime = None

        (allocatedCustodianToOwnerCid, _) <- exercise custodianToOwnerCid Instruction.Allocate with
          actors = onlyCustodian
          allocation = CreditReceiver
        approvedCustodianToOwnerCid <- exercise allocatedCustodianToOwnerCid Instruction.Approve with
          actors = onlyCustodian <> receiverAuthorisers
          approval = TakeDelivery account

        (allocatedCustodianToMbCid, _) <- exercise custodianToMbCid Instruction.Allocate with
          actors = onlyCustodian
          allocation = CreditReceiver
        takeDeliveryDelegationCid <- create TakeDeliveryDelegation with
          delegator = custodian
          delegate = minterBurner
          instructionCid = allocatedCustodianToMbCid
          account = AccountKey with custodian, owner = minterBurner, id = supplyAccountId

        pure MintRequestResult with
          batchCid
          takeDeliveryDelegationCid

    nonconsuming choice RequestBurn : BurnRequestResult
      with
        requestor : Party
        holdingCid : ContractId Holding.I
        id : Id
      controller requestor
      do
        let custodianRequestor = Set.fromList [custodian, requestor]

        holdingView <- exercise holdingCid Holding.GetView with viewer = requestor
        assertMsg "Requestor must be the owner" (holdingView.account.owner == requestor)
        assertMsg "Must have expected instrument" (holdingView.instrument == instrument)
        assertMsg "Must have expected custodian" (holdingView.account.custodian == custodian)

        let allActors = Set.fromList [custodian, requestor] <> receiverAuthorisers
            onlyCustodian = Set.fromList [custodian]
            quantity = Quantity with unit = holdingView.instrument, amount = holdingView.amount
        let ownerToCustodian = RoutedStep with
              custodian
              sender = holdingView.account.owner
              receiver = custodian
              quantity
            mbToCustodian = RoutedStep with
              custodian
              sender = minterBurner
              receiver = custodian
              quantity
        (batchCid, [ownerToCustodianCid, mbToCustodianCid]) <- exercise
          settlementFactoryCid
          SettlementFactory.Instruct with
            instructors = allActors
            settlers = Set.fromList [minterBurner]
            id
            description = "Burn: " <> displayInstrument instrument
            contextId = None
            routedSteps = [ownerToCustodian, mbToCustodian]
            settlementTime = None

        (allocatedOwnerToCustodianCid, _) <- exercise ownerToCustodianCid Instruction.Allocate with
          actors = allActors
          allocation = Pledge holdingCid

        -- TODO is the holding lock check needed?
        Pledge lockedHoldingCid <- (.allocation) <$> exercise allocatedOwnerToCustodianCid Instruction.GetView with
          viewer = requestor
        lockedHolding <- exercise lockedHoldingCid Holding.GetView with viewer = requestor
        let lockOpt = lockedHolding.lock
        assertMsg "Holding must have lock" (isSome lockOpt)
        let (Some lock) = lockOpt
        assertMsg "Holding must be locked by custodian" (Set.member custodian lock.lockers)

        approvedOwnerToCustodianCid <- exercise allocatedOwnerToCustodianCid Instruction.Approve with
          actors = onlyCustodian
          approval = DebitSender

        approvedMbToCustodianCid <- exercise mbToCustodianCid Instruction.Approve with
          actors = onlyCustodian
          approval = DebitSender

        pledgeDelegationCid <- create PledgeDelegation with
          delegator = custodian
          delegate = minterBurner
          instructionCid = approvedMbToCustodianCid

        pure BurnRequestResult with
          batchCid
          pledgeDelegationCid

template TakeDeliveryDelegation
  with
    delegator : Party
    delegate : Party
    instructionCid : ContractId Instruction.I
    account : AccountKey
  where
    signatory delegator

    observer delegate

    choice PerformTakeDeliveryApproval : ContractId Instruction.I
      controller delegate
      do
        exercise instructionCid Instruction.Approve with
          actors = Set.fromList [delegator, delegate]
          approval = TakeDelivery account

    choice CancelTakeDeliveryDelegation : ()
      controller delegate
      do
        pure ()

template PledgeDelegation
  with
    delegator : Party
    delegate : Party
    instructionCid : ContractId Instruction.I
  where
    signatory delegator

    observer delegate

    choice PerformPledgeAllocation : (ContractId Instruction.I, Optional (ContractId Holding.I))
      with
        holdingCid : ContractId Holding.I
      controller delegate
      do
        exercise instructionCid Instruction.Allocate with
          actors = Set.fromList [delegator, delegate]
          allocation = Pledge holdingCid

    choice CancelPledgeDelegation : ()
      controller delegate
      do
        pure ()
